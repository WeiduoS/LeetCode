{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Preface"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/","text":"1. Backpack 0-1 knapsack problem Description Given n items with size Ai, an integer m denotes the size of a backpack. How full you can fill this backpack? Question Link https://www.lintcode.com/problem/backpack/description Example I Input: [3,4,8,5], backpack size=10 Output: 9 Example II: Input: [2,3,5,7], backpack size=12 Output: 12 Questions LintCode - 92. Backpack Analysis Weight Limit(i) 0 1 2 3 4 5 6 7 8 9 10 11 w1 = 2 0 0 2 2 2 2 2 2 2 2 2 2 w2 = 3 0 0 2 3 3 5 5 5 5 5 5 5 w3 = 5 0 0 2 3 3 5 5 7 8 8 10 10 w4 = 7 0 0 2 3 3 5 5 7 8 9 10 10 Transform Function dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - wt[i - 1]] + wt[i - 1]) Template class Solution { public int backpack ( int w , int [] wt ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { if ( j = wt [ i - 1 ]) { dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ], dp [ i - 1 ][ j - wt [ i - 1 ]] + wt [ i - 1 ]); } else { dp [ i ][ j ] = dp [ i - 1 ][ j ]; } } } return dp [ n ][ w ]; } } Optimize class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [] dp = new int [ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = w ; j = 0 ; j --) { if ( j = wt [ i - 1 ]) { dp [ j ] = Math . max ( dp [ j ], dp [ j - wt [ i - 1 ]] + wt [ i - 1 ]); } } } return dp [ w ]; } }","title":"Backpack I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#1-backpack-0-1-knapsack-problem","text":"","title":"1. Backpack 0-1 knapsack problem"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#description","text":"Given n items with size Ai, an integer m denotes the size of a backpack. How full you can fill this backpack?","title":"Description"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#question-link","text":"https://www.lintcode.com/problem/backpack/description","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#example-i","text":"Input: [3,4,8,5], backpack size=10 Output: 9","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#example-ii","text":"Input: [2,3,5,7], backpack size=12 Output: 12","title":"Example II:"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#questions","text":"LintCode - 92. Backpack","title":"Questions"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#analysis","text":"Weight Limit(i) 0 1 2 3 4 5 6 7 8 9 10 11 w1 = 2 0 0 2 2 2 2 2 2 2 2 2 2 w2 = 3 0 0 2 3 3 5 5 5 5 5 5 5 w3 = 5 0 0 2 3 3 5 5 7 8 8 10 10 w4 = 7 0 0 2 3 3 5 5 7 8 9 10 10","title":"Analysis"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#transform-function","text":"dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - wt[i - 1]] + wt[i - 1])","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#template","text":"class Solution { public int backpack ( int w , int [] wt ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { if ( j = wt [ i - 1 ]) { dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ], dp [ i - 1 ][ j - wt [ i - 1 ]] + wt [ i - 1 ]); } else { dp [ i ][ j ] = dp [ i - 1 ][ j ]; } } } return dp [ n ][ w ]; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#optimize","text":"class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [] dp = new int [ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = w ; j = 0 ; j --) { if ( j = wt [ i - 1 ]) { dp [ j ] = Math . max ( dp [ j ], dp [ j - wt [ i - 1 ]] + wt [ i - 1 ]); } } } return dp [ w ]; } }","title":"Optimize"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/","text":"2. Backpack 0-1 knapsack problem Description There are n items and a backpack with size m. Given array A representing the size of each item and array V representing the value of each item. Example I Input: m = 10, A = [2, 3, 5, 7], V = [1, 5, 2, 4] Output: 9 Explanation: Put A[1] and A[3] into backpack, getting the maximum value V[1] + V[3] = 9 Example II Input: m = 10, A = [2, 3, 8], V = [2, 5, 8] Output: 10 Explanation: Put A[0] and A[2] into backpack, getting the maximum value V[0] + V[2] = 10 Questions LintCode - 125. Backpack II Analysis Weight / Value (i) 0 1 2 3 4 5 6 7 8 9 10 11 w1 = 1 v1 = 1 0 1 1 1 1 1 1 1 1 1 1 1 w2 = 2 v2 = 6 0 1 6 7 7 7 7 7 7 7 7 7 w3 = 5 v3 = 18 0 1 6 7 7 18 19 24 25 25 25 25 w4 = 6 v3 = 22 0 1 6 7 7 18 22 24 28 29 29 40 w5 = 7 v5 = 28 0 1 6 7 7 18 22 28 29 34 35 40 Transform Function dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - wt[i - 1]] + val[i - 1]) Template class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { if ( j = wt [ i - 1 ]) { dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ], dp [ i ][ j - wt [ i - 1 ]] + val [ i - 1 ]); } else { dp [ i ][ j ] = dp [ i - 1 ][ j ]; } } } return dp [ n ][ w ]; } } Optimize class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [] dp = new int [ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = w ; j = 0 ; j --) { if ( j = wt [ i - 1 ]) { dp [ j ] = Math . max ( dp [ j ], dp [ j - wt [ i - 1 ]] + val [ i - 1 ]); } } } return dp [ w ]; } }","title":"Backpack II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#2-backpack-0-1-knapsack-problem","text":"","title":"2. Backpack 0-1 knapsack problem"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#description","text":"There are n items and a backpack with size m. Given array A representing the size of each item and array V representing the value of each item.","title":"Description"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#example-i","text":"Input: m = 10, A = [2, 3, 5, 7], V = [1, 5, 2, 4] Output: 9 Explanation: Put A[1] and A[3] into backpack, getting the maximum value V[1] + V[3] = 9","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#example-ii","text":"Input: m = 10, A = [2, 3, 8], V = [2, 5, 8] Output: 10 Explanation: Put A[0] and A[2] into backpack, getting the maximum value V[0] + V[2] = 10","title":"Example II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#questions","text":"LintCode - 125. Backpack II","title":"Questions"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#analysis","text":"Weight / Value (i) 0 1 2 3 4 5 6 7 8 9 10 11 w1 = 1 v1 = 1 0 1 1 1 1 1 1 1 1 1 1 1 w2 = 2 v2 = 6 0 1 6 7 7 7 7 7 7 7 7 7 w3 = 5 v3 = 18 0 1 6 7 7 18 19 24 25 25 25 25 w4 = 6 v3 = 22 0 1 6 7 7 18 22 24 28 29 29 40 w5 = 7 v5 = 28 0 1 6 7 7 18 22 28 29 34 35 40","title":"Analysis"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#transform-function","text":"dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - wt[i - 1]] + val[i - 1])","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#template","text":"class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { if ( j = wt [ i - 1 ]) { dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ], dp [ i ][ j - wt [ i - 1 ]] + val [ i - 1 ]); } else { dp [ i ][ j ] = dp [ i - 1 ][ j ]; } } } return dp [ n ][ w ]; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#optimize","text":"class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [] dp = new int [ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = w ; j = 0 ; j --) { if ( j = wt [ i - 1 ]) { dp [ j ] = Math . max ( dp [ j ], dp [ j - wt [ i - 1 ]] + val [ i - 1 ]); } } } return dp [ w ]; } }","title":"Optimize"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/","text":"3. Backpack unbounded knapsack problem (UKP) Description Given n items with size wt_i and value v_i (i : 0 ~ n - 1), an integer W denotes the size of a backpack. Each item you can pick multiple times, How full you can fill this backpack to maximize the total value? Example I Input: A = [2, 3, 5, 7], V = [1, 5, 2, 4], m = 10 Output: 15 Explanation: Put three item 1 (A[1] = 3, V[1] = 5) into backpack. Example II Input: A = [1, 2, 3], V = [1, 2, 3], m = 5 Output: 5 Explanation: Strategy is not unique. For example, put five item 0 (A[0] = 1, V[0] = 1) into backpack. Question LintCode - 440. Backpack III Analysis Weight Limit(i) 0 1 2 3 4 5 6 7 8 9 10 w1 = 2 v1 = 1 0 0 1 1 2 2 3 3 4 4 5 w2 = 3 v2 = 5 0 0 1 5 5 6 10 10 11 15 15 w3 = 5 v3 = 2 0 0 1 5 5 6 10 10 11 15 15 w4 = 7 v4 = 4 0 0 1 5 5 6 10 10 11 15 15 Transform Function dp[i][j] = Math.max(dp[i - 1][j - k * wt[i - 1]] + k * val[i - 1] | k = 0) Template class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { for ( int k = 0 ; k * wt [ i - 1 ] = j ; k ++) { dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i - 1 ][ j - k * wt [ i - 1 ]] + k * val [ i - 1 ]); } } } return dp [ n ][ w ]; } } Optimize Transform Function dp[i][j] = Math.max(dp[i - 1][j - k * wt[i - 1]] + k * val[i - 1] | k = 0) dp[i][j] = Math.max(dp[i - 1][j], max{dp[i - 1][j - k * wt[i - 1] + k * val[i - 1] | k = 1}) dp[i][j] = Math.max(dp[i - 1][j], max{dp[i - 1][(j - w[i - 1]) - k * wt[i - 1] + k * val[i - 1] | k = 0} + val[i - 1]) dp[i][j] = Math.max(dp[i - 1][j], max{dp[i][j - w[i - 1] + val[i - 1]) Optimize I class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { if ( j wt [ i - 1 ]) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; } else { dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ], dp [ i ][ j - wt [ i - 1 ]] + val [ i - 1 ]); } } } return dp [ n ][ w ]; } } Optimize II class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [] dp = new int [ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = wt [ i - 1 ]; j = w ; j ++) { dp [ j ] = Math . max ( dp [ j ], dp [ j - wt [ i - 1 ]] + val [ i - 1 ]); } } return dp [ w ]; } }","title":"Backpack III"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#3-backpack-unbounded-knapsack-problem-ukp","text":"","title":"3. Backpack unbounded knapsack problem (UKP)"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#description","text":"Given n items with size wt_i and value v_i (i : 0 ~ n - 1), an integer W denotes the size of a backpack. Each item you can pick multiple times, How full you can fill this backpack to maximize the total value?","title":"Description"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#example-i","text":"Input: A = [2, 3, 5, 7], V = [1, 5, 2, 4], m = 10 Output: 15 Explanation: Put three item 1 (A[1] = 3, V[1] = 5) into backpack.","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#example-ii","text":"Input: A = [1, 2, 3], V = [1, 2, 3], m = 5 Output: 5 Explanation: Strategy is not unique. For example, put five item 0 (A[0] = 1, V[0] = 1) into backpack.","title":"Example II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#question","text":"LintCode - 440. Backpack III","title":"Question"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#analysis","text":"Weight Limit(i) 0 1 2 3 4 5 6 7 8 9 10 w1 = 2 v1 = 1 0 0 1 1 2 2 3 3 4 4 5 w2 = 3 v2 = 5 0 0 1 5 5 6 10 10 11 15 15 w3 = 5 v3 = 2 0 0 1 5 5 6 10 10 11 15 15 w4 = 7 v4 = 4 0 0 1 5 5 6 10 10 11 15 15","title":"Analysis"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#transform-function","text":"dp[i][j] = Math.max(dp[i - 1][j - k * wt[i - 1]] + k * val[i - 1] | k = 0)","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#template","text":"class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { for ( int k = 0 ; k * wt [ i - 1 ] = j ; k ++) { dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i - 1 ][ j - k * wt [ i - 1 ]] + k * val [ i - 1 ]); } } } return dp [ n ][ w ]; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#optimize-transform-function","text":"dp[i][j] = Math.max(dp[i - 1][j - k * wt[i - 1]] + k * val[i - 1] | k = 0) dp[i][j] = Math.max(dp[i - 1][j], max{dp[i - 1][j - k * wt[i - 1] + k * val[i - 1] | k = 1}) dp[i][j] = Math.max(dp[i - 1][j], max{dp[i - 1][(j - w[i - 1]) - k * wt[i - 1] + k * val[i - 1] | k = 0} + val[i - 1]) dp[i][j] = Math.max(dp[i - 1][j], max{dp[i][j - w[i - 1] + val[i - 1])","title":"Optimize Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#optimize-i","text":"class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { if ( j wt [ i - 1 ]) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; } else { dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ], dp [ i ][ j - wt [ i - 1 ]] + val [ i - 1 ]); } } } return dp [ n ][ w ]; } }","title":"Optimize I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#optimize-ii","text":"class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [] dp = new int [ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = wt [ i - 1 ]; j = w ; j ++) { dp [ j ] = Math . max ( dp [ j ], dp [ j - wt [ i - 1 ]] + val [ i - 1 ]); } } return dp [ w ]; } }","title":"Optimize II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/","text":"4. Backpack bounded knapsack problem (BKP) Description Assume that you have n yuan. There are many kinds of rice in the supermarket. Each kind of rice is bagged and must be purchased in the whole bag. Given the weight, price and quantity of each type of rice, find the maximum weight of rice that you can purchase. Example I Input: n = 8, prices = [3,2], weights = [300,160], amounts = [1,6] Output: 640 Explanation: Buy the second rice(price = 2) use all 8 money. Example II Input: n = 8, prices = [2,4], weight = [100,100], amounts = [4,2 ] Output: 400 Explanation: Buy the first rice(price = 2) use all 8 money. Question LintCode - 798. Backpack VII Transform Function dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k * prices[i - 1]] + k * weight[i - 1]); Template class Solution { public int backpack ( int n , int [] prices , int [] weight , int [] amounts ) { int m = prices . length ; int [][] dp = new int [ m + 1 ][ n + 1 ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 1 ; j = n ; j ++) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; for ( int k = 1 ; k = amounts [ i - 1 ] k * prices [ i - 1 ] = j ; k ++) { dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i - 1 ][ j - k * prices [ i - 1 ]] + k * weight [ i - 1 ]); } } } return dp [ m ][ n ]; } } Another Template class Solution { public int backpack ( int n , int [] prices , int [] weight , int [] amounts ) { int m = prices . length ; int [][] dp = new int [ m + 1 ][ n + 1 ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = amounts [ i - 1 ]; j ++) { for ( int k = 1 ; k = n ; k ++) { if ( k = j * prices [ i - 1 ]) dp [ i ][ k ] = Math . max ( dp [ i ][ k ], dp [ i - 1 ][ k - j * prices [ i - 1 ]] + j * weight [ i - 1 ]); } } } return dp [ m ][ n ]; } } Optimize Analysis Wrong Answer: for (int i = 1; i = n; ++i) { for (int j = 1; j = amounts[i - 1]; ++j) { for (int k = n; k = j * prices[i - 1]; --k) { dp[k] = max(dp[k], dp[k - j * prices[i - 1]] + j * weight[i - 1]); } } } 1. dp[i - 1][k - j * prices[i - 1]] + j * weight[i - 1])\uff0c j = 0\u2026amounts[i-1] Max(dp[i][j], dp[i - 1][j]) 2. dp[k - prices[i - 1]] + weight[i - 1] (j = 1) is the max because k is from max to 1 so dp[k - j * prices[i - 1]] + j * weight[i - 1] is wrong 3. tip: j should begin from 1, because dp[k - (amounts[i - 1] + 1) * prices[i - 1]] is meaningless Optimize I class Solution { public int backpack ( int n , int [] prices , int [] weight , int [] amounts ) { int m = prices . length ; int [] dp = new int [ n + 1 ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 1 ; j = amounts [ i - 1 ]; j ++){ for ( int k = n ; k = prices [ i - 1 ]; k --) { dp [ k ] = Math . max ( dp [ k ], dp [ k - prices [ i - 1 ]] + weight [ i - 1 ]); } } } return dp [ n ]; } }","title":"Backpack IV"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#4-backpack-bounded-knapsack-problem-bkp","text":"","title":"4. Backpack bounded knapsack problem (BKP)"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#description","text":"Assume that you have n yuan. There are many kinds of rice in the supermarket. Each kind of rice is bagged and must be purchased in the whole bag. Given the weight, price and quantity of each type of rice, find the maximum weight of rice that you can purchase.","title":"Description"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#example-i","text":"Input: n = 8, prices = [3,2], weights = [300,160], amounts = [1,6] Output: 640 Explanation: Buy the second rice(price = 2) use all 8 money.","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#example-ii","text":"Input: n = 8, prices = [2,4], weight = [100,100], amounts = [4,2 ] Output: 400 Explanation: Buy the first rice(price = 2) use all 8 money.","title":"Example II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#question","text":"LintCode - 798. Backpack VII","title":"Question"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#transform-function","text":"dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k * prices[i - 1]] + k * weight[i - 1]);","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#template","text":"class Solution { public int backpack ( int n , int [] prices , int [] weight , int [] amounts ) { int m = prices . length ; int [][] dp = new int [ m + 1 ][ n + 1 ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 1 ; j = n ; j ++) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; for ( int k = 1 ; k = amounts [ i - 1 ] k * prices [ i - 1 ] = j ; k ++) { dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i - 1 ][ j - k * prices [ i - 1 ]] + k * weight [ i - 1 ]); } } } return dp [ m ][ n ]; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#another-template","text":"class Solution { public int backpack ( int n , int [] prices , int [] weight , int [] amounts ) { int m = prices . length ; int [][] dp = new int [ m + 1 ][ n + 1 ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = amounts [ i - 1 ]; j ++) { for ( int k = 1 ; k = n ; k ++) { if ( k = j * prices [ i - 1 ]) dp [ i ][ k ] = Math . max ( dp [ i ][ k ], dp [ i - 1 ][ k - j * prices [ i - 1 ]] + j * weight [ i - 1 ]); } } } return dp [ m ][ n ]; } }","title":"Another Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#optimize-analysis","text":"Wrong Answer: for (int i = 1; i = n; ++i) { for (int j = 1; j = amounts[i - 1]; ++j) { for (int k = n; k = j * prices[i - 1]; --k) { dp[k] = max(dp[k], dp[k - j * prices[i - 1]] + j * weight[i - 1]); } } } 1. dp[i - 1][k - j * prices[i - 1]] + j * weight[i - 1])\uff0c j = 0\u2026amounts[i-1] Max(dp[i][j], dp[i - 1][j]) 2. dp[k - prices[i - 1]] + weight[i - 1] (j = 1) is the max because k is from max to 1 so dp[k - j * prices[i - 1]] + j * weight[i - 1] is wrong 3. tip: j should begin from 1, because dp[k - (amounts[i - 1] + 1) * prices[i - 1]] is meaningless","title":"Optimize Analysis"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#optimize-i","text":"class Solution { public int backpack ( int n , int [] prices , int [] weight , int [] amounts ) { int m = prices . length ; int [] dp = new int [ n + 1 ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 1 ; j = amounts [ i - 1 ]; j ++){ for ( int k = n ; k = prices [ i - 1 ]; k --) { dp [ k ] = Math . max ( dp [ k ], dp [ k - prices [ i - 1 ]] + weight [ i - 1 ]); } } } return dp [ n ]; } }","title":"Optimize I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/","text":"5. Backpack bounded knapsack problem (BKP) Description Given an integer array nums[] which contains n unique positive numbers, num[i] indicate the size of ith item. An integer target denotes the size of backpack. Find the number of ways to fill the backpack. Each item may be chosen unlimited number of times Example I Input: nums = [2,3,6,7] and target = 7 Output: 2 Explanation: Solution sets are: [7], [2, 2, 3] Example II Input: nums = [2,3,4,5] and target = 7 Output: 3 Explanation: Solution sets are: [2, 5], [3, 4], [2, 2, 3] Question LintCode - 562. Backpack IV Transform Function dp[i][j] += dp[i][j - 1]; dp[i][j] += dp[i - 1][j - k * nums[i - 1]]; Template class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [][] dp = new int [ n + 1 ][ target + 1 ]; for ( int i = 0 ; i = n ; i ++) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = target ; j ++) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; for ( int k = 1 ; k * nums [ i - 1 ] = j ; k ++) { dp [ i ][ j ] += dp [ i - 1 ][ j - k * nums [ i - 1 ]]; } } } return dp [ n ][ target ]; } } Optimize I class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [] dp = new int [ target + 1 ]; dp [ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = nums [ i - 1 ]; j = target ; j ++) { dp [ j ] += dp [ j - nums [ i - 1 ]]; } } return dp [ target ]; } }","title":"Backpack V"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#5-backpack-bounded-knapsack-problem-bkp","text":"","title":"5. Backpack bounded knapsack problem (BKP)"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#description","text":"Given an integer array nums[] which contains n unique positive numbers, num[i] indicate the size of ith item. An integer target denotes the size of backpack. Find the number of ways to fill the backpack. Each item may be chosen unlimited number of times","title":"Description"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#example-i","text":"Input: nums = [2,3,6,7] and target = 7 Output: 2 Explanation: Solution sets are: [7], [2, 2, 3]","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#example-ii","text":"Input: nums = [2,3,4,5] and target = 7 Output: 3 Explanation: Solution sets are: [2, 5], [3, 4], [2, 2, 3]","title":"Example II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#question","text":"LintCode - 562. Backpack IV","title":"Question"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#transform-function","text":"dp[i][j] += dp[i][j - 1]; dp[i][j] += dp[i - 1][j - k * nums[i - 1]];","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#template","text":"class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [][] dp = new int [ n + 1 ][ target + 1 ]; for ( int i = 0 ; i = n ; i ++) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = target ; j ++) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; for ( int k = 1 ; k * nums [ i - 1 ] = j ; k ++) { dp [ i ][ j ] += dp [ i - 1 ][ j - k * nums [ i - 1 ]]; } } } return dp [ n ][ target ]; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#optimize-i","text":"class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [] dp = new int [ target + 1 ]; dp [ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = nums [ i - 1 ]; j = target ; j ++) { dp [ j ] += dp [ j - nums [ i - 1 ]]; } } return dp [ target ]; } }","title":"Optimize I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/","text":"6. Backpack bounded knapsack problem (BKP) Description Given n items with size nums[i] which an integer array and all positive numbers. An integer target denotes the size of a backpack. Find the number of possible fill the backpack. Each item may only be used once Example I Input: [1,2,3,3,7] and target 7, Output: A solution set is: [7],[1, 3, 3] Question LintCode - 563. Backpack V Transform Function dp[i][j] += dp[i][j - 1]; dp[i][j] += dp[i - 1][j - nums[i - 1]]; Template class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [][] dp = new int [ n + 1 ][ target + 1 ]; for ( int i = 0 ; i = n ; i ++) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = target ; j ++) { dp [ i ][ j ] += dp [ i - 1 ][ j ]; if ( j = nums [ i - 1 ]) dp [ i ][ j ] += dp [ i - 1 ][ j - nums [ i - 1 ]]; } } return dp [ n ][ target ]; } } Optimize I class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [] dp = new int [ target + 1 ]; dp [ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = target ; j = nums [ i - 1 ]; j --) { dp [ j ] += dp [ j - nums [ i - 1 ]]; } } return dp [ target ]; } }","title":"Backpack VI"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/#6-backpack-bounded-knapsack-problem-bkp","text":"","title":"6. Backpack bounded knapsack problem (BKP)"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/#description","text":"Given n items with size nums[i] which an integer array and all positive numbers. An integer target denotes the size of a backpack. Find the number of possible fill the backpack. Each item may only be used once","title":"Description"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/#example-i","text":"Input: [1,2,3,3,7] and target 7, Output: A solution set is: [7],[1, 3, 3]","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/#question","text":"LintCode - 563. Backpack V","title":"Question"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/#transform-function","text":"dp[i][j] += dp[i][j - 1]; dp[i][j] += dp[i - 1][j - nums[i - 1]];","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/#template","text":"class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [][] dp = new int [ n + 1 ][ target + 1 ]; for ( int i = 0 ; i = n ; i ++) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = target ; j ++) { dp [ i ][ j ] += dp [ i - 1 ][ j ]; if ( j = nums [ i - 1 ]) dp [ i ][ j ] += dp [ i - 1 ][ j - nums [ i - 1 ]]; } } return dp [ n ][ target ]; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/#optimize-i","text":"class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [] dp = new int [ target + 1 ]; dp [ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = target ; j = nums [ i - 1 ]; j --) { dp [ j ] += dp [ j - nums [ i - 1 ]]; } } return dp [ target ]; } }","title":"Optimize I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/","text":"7. Backpack bounded knapsack problem (BKP) Description Give some coins of different value and their quantity. Find how many values which are in range 1 ~ n can these coins be combined Example I Input: n = 5 value = [1,4] amount = [2,1] Output: 4 Explanation: They can combine 4 numbers which are 1,2,4,5. Example II Input: n = 10 value = [1,2,4] amount = [2,1,1] Output: 8 Explanation: They can combine 8 numbers which are 1 ~ 8. Question LintCode - 799. Backpack VIII Transform Function dp[i][j] = dp[i - 1][j]; dp[i][j] |= dp[i - 1][j - k * value[i - 1]]; Template class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; boolean [][] dp = new boolean [ m + 1 ][ n + 1 ]; dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = n ; j ++) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; for ( int k = 1 ; k = amount [ i - 1 ] k * value [ i - 1 ] = j ; k ++) { dp [ i ][ j ] |= dp [ i - 1 ][ j - k * value [ i - 1 ]]; } } } int sum = 0 ; for ( int i = 1 ; i = n ; i ++) sum += dp [ m ][ i ] == true ? 1 : 0 ; return sum ; } } Optimize Analysis dp[i][j] : how many item i will be remained, when using items before i to get j; initialization: long[][] dp = new long[m + 1][n + 1]; Arrays.fill(dp[0],-1); dp[0][0] = 0; transform function: amount[i - 1] (dp[i - 1][j] = 0) dp[i][j] = -1 (j value[i - 1] || dp[i][j - value[i - 1]] = 0) dp[i + 1][j - value[i - 1] - 1 (other) Optimize I (Memory Limit Exceeded) class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; long [][] dp = new long [ m + 1 ][ n + 1 ]; Arrays . fill ( dp [ 0 ],- 1 ); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = n ; j ++) { if ( dp [ i - 1 ][ j ] = 0 ) { dp [ i ][ j ] = amount [ i - 1 ]; } else if ( j value [ i - 1 ] || dp [ i ][ j - value [ i - 1 ]] = 0 ) { dp [ i ][ j ] = - 1 ; } else { dp [ i ][ j ] = dp [ i ][ j - value [ i - 1 ]] - 1 ; } } } int sum = 0 ; for ( int i = 1 ; i = n ; ++ i ) { if ( dp [ m ][ i ] = 0 ) sum ++; } return sum ; } } Optimize II class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; long [] dp = new long [ n + 1 ]; Arrays . fill ( dp , - 1 ); dp [ 0 ] = 0 ; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = n ; j ++) { if ( dp [ j ] = 0 ) { dp [ j ] = amount [ i - 1 ]; } else if ( j value [ i - 1 ] || dp [ j - value [ i - 1 ]] = 0 ) { dp [ j ] = - 1 ; } else { dp [ j ] = dp [ j - value [ i - 1 ]] - 1 ; } } } int sum = 0 ; for ( int i = 1 ; i = n ; ++ i ) { if ( dp [ i ] = 0 ) sum ++; } return sum ; } } Optimize III class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; boolean [] dp = new boolean [ n + 1 ]; dp [ 0 ] = true ; int res = 0 ; for ( int i = 1 ; i = m ; i ++) { int [] cnt = new int [ n + 1 ]; for ( int j = value [ i - 1 ]; j = n ; j ++) { if (! dp [ j ] dp [ j - value [ i - 1 ]] cnt [ j - value [ i - 1 ]] amount [ i - 1 ]) { res ++; dp [ j ] = true ; cnt [ j ] = cnt [ j - value [ i - 1 ]] + 1 ; } } } return res ; } }","title":"Backpack VII"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#7-backpack-bounded-knapsack-problem-bkp","text":"","title":"7. Backpack bounded knapsack problem (BKP)"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#description","text":"Give some coins of different value and their quantity. Find how many values which are in range 1 ~ n can these coins be combined","title":"Description"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#example-i","text":"Input: n = 5 value = [1,4] amount = [2,1] Output: 4 Explanation: They can combine 4 numbers which are 1,2,4,5.","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#example-ii","text":"Input: n = 10 value = [1,2,4] amount = [2,1,1] Output: 8 Explanation: They can combine 8 numbers which are 1 ~ 8.","title":"Example II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#question","text":"LintCode - 799. Backpack VIII","title":"Question"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#transform-function","text":"dp[i][j] = dp[i - 1][j]; dp[i][j] |= dp[i - 1][j - k * value[i - 1]];","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#template","text":"class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; boolean [][] dp = new boolean [ m + 1 ][ n + 1 ]; dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = n ; j ++) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; for ( int k = 1 ; k = amount [ i - 1 ] k * value [ i - 1 ] = j ; k ++) { dp [ i ][ j ] |= dp [ i - 1 ][ j - k * value [ i - 1 ]]; } } } int sum = 0 ; for ( int i = 1 ; i = n ; i ++) sum += dp [ m ][ i ] == true ? 1 : 0 ; return sum ; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#optimize-analysis","text":"dp[i][j] : how many item i will be remained, when using items before i to get j; initialization: long[][] dp = new long[m + 1][n + 1]; Arrays.fill(dp[0],-1); dp[0][0] = 0; transform function: amount[i - 1] (dp[i - 1][j] = 0) dp[i][j] = -1 (j value[i - 1] || dp[i][j - value[i - 1]] = 0) dp[i + 1][j - value[i - 1] - 1 (other)","title":"Optimize Analysis"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#optimize-i-memory-limit-exceeded","text":"class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; long [][] dp = new long [ m + 1 ][ n + 1 ]; Arrays . fill ( dp [ 0 ],- 1 ); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = n ; j ++) { if ( dp [ i - 1 ][ j ] = 0 ) { dp [ i ][ j ] = amount [ i - 1 ]; } else if ( j value [ i - 1 ] || dp [ i ][ j - value [ i - 1 ]] = 0 ) { dp [ i ][ j ] = - 1 ; } else { dp [ i ][ j ] = dp [ i ][ j - value [ i - 1 ]] - 1 ; } } } int sum = 0 ; for ( int i = 1 ; i = n ; ++ i ) { if ( dp [ m ][ i ] = 0 ) sum ++; } return sum ; } }","title":"Optimize I (Memory Limit Exceeded)"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#optimize-ii","text":"class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; long [] dp = new long [ n + 1 ]; Arrays . fill ( dp , - 1 ); dp [ 0 ] = 0 ; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = n ; j ++) { if ( dp [ j ] = 0 ) { dp [ j ] = amount [ i - 1 ]; } else if ( j value [ i - 1 ] || dp [ j - value [ i - 1 ]] = 0 ) { dp [ j ] = - 1 ; } else { dp [ j ] = dp [ j - value [ i - 1 ]] - 1 ; } } } int sum = 0 ; for ( int i = 1 ; i = n ; ++ i ) { if ( dp [ i ] = 0 ) sum ++; } return sum ; } }","title":"Optimize II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#optimize-iii","text":"class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; boolean [] dp = new boolean [ n + 1 ]; dp [ 0 ] = true ; int res = 0 ; for ( int i = 1 ; i = m ; i ++) { int [] cnt = new int [ n + 1 ]; for ( int j = value [ i - 1 ]; j = n ; j ++) { if (! dp [ j ] dp [ j - value [ i - 1 ]] cnt [ j - value [ i - 1 ]] amount [ i - 1 ]) { res ++; dp [ j ] = true ; cnt [ j ] = cnt [ j - value [ i - 1 ]] + 1 ; } } } return res ; } }","title":"Optimize III"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/","text":"1. Catalan number problem Description Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Question Link https://leetcode.com/problems/unique-binary-search-trees/description/ Example I Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST s: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 Questions LeetCode - 96. Unique Binary Search Trees Analysis Transform Function Solution I class Solution { public int numTrees ( int n ) { int [] dp = new int [ n + 1 ]; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i = n ; i ++) { for ( int j = 0 ; j i ; j ++) { dp [ i ] += dp [ j ] * dp [ i - j - 1 ]; } } return dp [ n ]; } } Solution II class Solution { public int numTrees ( int n ) { long res = 1 ; for ( int i = 0 ; i n ; i ++) { res = res * 2 * ( 2 * i + 1 ) / ( i + 2 ); } return ( int ) res ; } }","title":"Calatan Number I"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#1-catalan-number-problem","text":"","title":"1. Catalan number problem"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#description","text":"Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?","title":"Description"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#question-link","text":"https://leetcode.com/problems/unique-binary-search-trees/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#example-i","text":"Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST s: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#questions","text":"LeetCode - 96. Unique Binary Search Trees","title":"Questions"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#analysis","text":"","title":"Analysis"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#transform-function","text":"","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#solution-i","text":"class Solution { public int numTrees ( int n ) { int [] dp = new int [ n + 1 ]; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i = n ; i ++) { for ( int j = 0 ; j i ; j ++) { dp [ i ] += dp [ j ] * dp [ i - j - 1 ]; } } return dp [ n ]; } }","title":"Solution I"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#solution-ii","text":"class Solution { public int numTrees ( int n ) { long res = 1 ; for ( int i = 0 ; i n ; i ++) { res = res * 2 * ( 2 * i + 1 ) / ( i + 2 ); } return ( int ) res ; } }","title":"Solution II"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/","text":"Multiple States Description Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Question Link https://leetcode.com/problems/maximum-product-subarray/description/ Example I Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example II: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Questions LeetCode - 152. Maximum Product Subarray Transform Function f(k) = Largest product subarray, from index 0 up to k. g(k) = Smallest product subarray, from index 0 up to k. f(k) = max( f(k-1) A[k], A[k], g(k-1) A[k] ) g(k) = min( g(k-1) A[k], A[k], f(k-1) A[k] ) Template class Solution { public int maxProduct ( int [] nums ) { assert nums . length 0 ; int max = nums [ 0 ], min = nums [ 0 ], res = nums [ 0 ]; for ( int i = 1 ; i nums . length ; i ++) { int mx = max , mn = min ; max = Math . max ( Math . max ( nums [ i ], mx * nums [ i ]), mn * nums [ i ]); min = Math . min ( Math . min ( nums [ i ], mx * nums [ i ]), mn * nums [ i ]); res = Math . max ( res , max ); } return res ; } }","title":"Multiple States I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#multiple-states","text":"","title":"Multiple States"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#description","text":"Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.","title":"Description"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#question-link","text":"https://leetcode.com/problems/maximum-product-subarray/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#example-i","text":"Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.","title":"Example I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#example-ii","text":"Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.","title":"Example II:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#questions","text":"LeetCode - 152. Maximum Product Subarray","title":"Questions"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#transform-function","text":"f(k) = Largest product subarray, from index 0 up to k. g(k) = Smallest product subarray, from index 0 up to k. f(k) = max( f(k-1) A[k], A[k], g(k-1) A[k] ) g(k) = min( g(k-1) A[k], A[k], f(k-1) A[k] )","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#template","text":"class Solution { public int maxProduct ( int [] nums ) { assert nums . length 0 ; int max = nums [ 0 ], min = nums [ 0 ], res = nums [ 0 ]; for ( int i = 1 ; i nums . length ; i ++) { int mx = max , mn = min ; max = Math . max ( Math . max ( nums [ i ], mx * nums [ i ]), mn * nums [ i ]); min = Math . min ( Math . min ( nums [ i ], mx * nums [ i ]), mn * nums [ i ]); res = Math . max ( res , max ); } return res ; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/","text":"Multiple States Description Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Question Link https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/ Example I Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example II: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. Questions LeetCode - 121. Best Time to Buy and Sell Stock Transform Function dp[i] = prices[i] - min_prices Template I class Solution { public int maxProfit ( int [] prices ) { int n = prices . length ; int [] dp = new int [ n + 1 ]; dp [ 0 ] = Integer . MAX_VALUE ; int min = Integer . MAX_VALUE , res = 0 ; for ( int i = 1 ; i = n ; i ++) { min = Math . min ( min , prices [ i - 1 ]); dp [ i ] = min ; res = Math . max ( res , prices [ i - 1 ] - dp [ i - 1 ]); } return res ; } } Optimized min = min_price_before res = Math.max(prices[i] - min) Template II class Solution { public int maxProfit ( int [] prices ) { int min = Integer . MAX_VALUE , res = 0 ; for ( int p : prices ) { min = Math . min ( p , min ); res = Math . max ( p - min , res ); } return res ; } }","title":"Multiple States II"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#multiple-states","text":"","title":"Multiple States"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#description","text":"Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one.","title":"Description"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#question-link","text":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#example-i","text":"Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price.","title":"Example I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#example-ii","text":"Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.","title":"Example II:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#questions","text":"LeetCode - 121. Best Time to Buy and Sell Stock","title":"Questions"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#transform-function","text":"dp[i] = prices[i] - min_prices","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#template-i","text":"class Solution { public int maxProfit ( int [] prices ) { int n = prices . length ; int [] dp = new int [ n + 1 ]; dp [ 0 ] = Integer . MAX_VALUE ; int min = Integer . MAX_VALUE , res = 0 ; for ( int i = 1 ; i = n ; i ++) { min = Math . min ( min , prices [ i - 1 ]); dp [ i ] = min ; res = Math . max ( res , prices [ i - 1 ] - dp [ i - 1 ]); } return res ; } }","title":"Template I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#optimized","text":"min = min_price_before res = Math.max(prices[i] - min)","title":"Optimized"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#template-ii","text":"class Solution { public int maxProfit ( int [] prices ) { int min = Integer . MAX_VALUE , res = 0 ; for ( int p : prices ) { min = Math . min ( p , min ); res = Math . max ( p - min , res ); } return res ; } }","title":"Template II"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/","text":"Multiple States Description Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Question Link https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/ Example I: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example II: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example III: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. Questions LeetCode - 123. Best Time to Buy and Sell Stock III Transform Function before[i] = Math.max(before[i - 1], prices[i] - min); after[i] = Math.max(after[i + 1], max - prices[i]); res = Math.max(before[i] + after[i], res); TemplateI class Solution { public int maxProfit ( int [] prices ) { if ( prices == null || prices . length = 1 ) return 0 ; int n = prices . length ; int [] before = new int [ n ]; int min = prices [ 0 ]; for ( int i = 1 ; i n ; i ++) { min = Math . min ( min , prices [ i ]); before [ i ] = Math . max ( before [ i - 1 ], prices [ i ] - min ); } int [] after = new int [ n ]; int max = prices [ n - 1 ]; for ( int i = n - 2 ; i = 0 ; i --) { max = Math . max ( prices [ i ], max ); after [ i ] = Math . max ( after [ i + 1 ], max - prices [ i ]); } int res = 0 ; for ( int i = 0 ; i n ; i ++) res = Math . max ( before [ i ] + after [ i ], res ); return res ; } } Optimized i = 1, j = 3 dp[1][0] - prices[0] + prices[3] dp[1][1] - prices[1] + prices[3] dp[1][2] - prices[2] + prices[3] Template II class Solution { public int maxProfit ( int k , int [] prices ) { if ( k == 0 || prices . length == 0 ) return 0 ; if ( k = prices . length / 2 ) return helper ( prices ); int n = prices . length ; int [] dp = new int [ n ]; int [] prev = new int [ n ]; for ( int i = 1 ; i = k ; i ++) { int maxDiff = - prices [ 0 ]; for ( int j = 1 ; j n ; j ++) { dp [ j ] = Math . max ( dp [ j - 1 ], maxDiff + prices [ j ]); maxDiff = Math . max ( maxDiff , prev [ j ] - prices [ j ]); } prev = Arrays . copyOf ( dp , dp . length ); } return dp [ n - 1 ]; } int helper ( int [] prices ) { int res = 0 ; for ( int i = 1 ; i prices . length ; i ++) { if ( prices [ i ] prices [ i - 1 ]) res += prices [ i ] - prices [ i - 1 ]; } return res ; } } Optimized transaction on i th day dp[i] = max{dp[i - 1][no tansaction] + sell, dp[i - 1][do transaction] + buy} for (int i = 0; i n; i++) { dp[i][no transaction] = max(dp[i - 1][do transaction] + buy, dp[i - 1][no tansaction] + hold ); dp[i][do transaction] = max(dp[i - 1][no transaction] + sell, dp[i - 1][do transaction] + hold ); } return dp[n - 1][do transaction]; for (int i = 0; i n; i++) { for (int j = 0; j = k; j++) { dp[i][no transaction][j] = max {dp[i - 1][do transaction][j - 1] + buy, dp[i - 1][no transaction][j] + hold }; dp[i][do transaction][j] = max {dp[i - 1][no transaction][j] + sell, dp[i - 1][do transaction][j] + hold }; } } return dp[n-1][do transaction]; hold[i][j] = max {sold[i - 1][j - 1] + buy, hold[i - 1][j]} sold[i][j] = max {hold[i - 1][j] + sell, sold[i - 1][j]} Template III class Solution { public int maxProfit ( int k , int [] prices ) { if ( k == 0 || prices . length == 0 ) return 0 ; if ( k = prices . length / 2 ) return helper ( prices ); int n = prices . length ; int [][] hold = new int [ n ][ k + 1 ]; int [][] sold = new int [ n ][ k + 1 ]; for ( int i = 1 ; i n ; i ++) { int diff = prices [ i ] - prices [ i - 1 ]; for ( int j = 1 ; j = k ; j ++) { hold [ i ][ j ] = Math . max ( sold [ i - 1 ][ j - 1 ] + diff , hold [ i - 1 ][ j ] + diff ); sold [ i ][ j ] = Math . max ( hold [ i ][ j ], sold [ i - 1 ][ j ]); } } return sold [ n - 1 ][ k ]; } int helper ( int [] prices ) { int res = 0 ; for ( int i = 1 ; i prices . length ; i ++) { if ( prices [ i ] prices [ i - 1 ]) res += prices [ i ] - prices [ i - 1 ]; } return res ; } }","title":"Multiple States III"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#multiple-states","text":"","title":"Multiple States"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#description","text":"Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).","title":"Description"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#question-link","text":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#example-i","text":"Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.","title":"Example I:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#example-ii","text":"Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.","title":"Example II:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#example-iii","text":"Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.","title":"Example III:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#questions","text":"LeetCode - 123. Best Time to Buy and Sell Stock III","title":"Questions"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#transform-function","text":"before[i] = Math.max(before[i - 1], prices[i] - min); after[i] = Math.max(after[i + 1], max - prices[i]); res = Math.max(before[i] + after[i], res);","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#templatei","text":"class Solution { public int maxProfit ( int [] prices ) { if ( prices == null || prices . length = 1 ) return 0 ; int n = prices . length ; int [] before = new int [ n ]; int min = prices [ 0 ]; for ( int i = 1 ; i n ; i ++) { min = Math . min ( min , prices [ i ]); before [ i ] = Math . max ( before [ i - 1 ], prices [ i ] - min ); } int [] after = new int [ n ]; int max = prices [ n - 1 ]; for ( int i = n - 2 ; i = 0 ; i --) { max = Math . max ( prices [ i ], max ); after [ i ] = Math . max ( after [ i + 1 ], max - prices [ i ]); } int res = 0 ; for ( int i = 0 ; i n ; i ++) res = Math . max ( before [ i ] + after [ i ], res ); return res ; } }","title":"TemplateI"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#optimized","text":"i = 1, j = 3 dp[1][0] - prices[0] + prices[3] dp[1][1] - prices[1] + prices[3] dp[1][2] - prices[2] + prices[3]","title":"Optimized"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#template-ii","text":"class Solution { public int maxProfit ( int k , int [] prices ) { if ( k == 0 || prices . length == 0 ) return 0 ; if ( k = prices . length / 2 ) return helper ( prices ); int n = prices . length ; int [] dp = new int [ n ]; int [] prev = new int [ n ]; for ( int i = 1 ; i = k ; i ++) { int maxDiff = - prices [ 0 ]; for ( int j = 1 ; j n ; j ++) { dp [ j ] = Math . max ( dp [ j - 1 ], maxDiff + prices [ j ]); maxDiff = Math . max ( maxDiff , prev [ j ] - prices [ j ]); } prev = Arrays . copyOf ( dp , dp . length ); } return dp [ n - 1 ]; } int helper ( int [] prices ) { int res = 0 ; for ( int i = 1 ; i prices . length ; i ++) { if ( prices [ i ] prices [ i - 1 ]) res += prices [ i ] - prices [ i - 1 ]; } return res ; } }","title":"Template II"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#optimized_1","text":"transaction on i th day dp[i] = max{dp[i - 1][no tansaction] + sell, dp[i - 1][do transaction] + buy} for (int i = 0; i n; i++) { dp[i][no transaction] = max(dp[i - 1][do transaction] + buy, dp[i - 1][no tansaction] + hold ); dp[i][do transaction] = max(dp[i - 1][no transaction] + sell, dp[i - 1][do transaction] + hold ); } return dp[n - 1][do transaction]; for (int i = 0; i n; i++) { for (int j = 0; j = k; j++) { dp[i][no transaction][j] = max {dp[i - 1][do transaction][j - 1] + buy, dp[i - 1][no transaction][j] + hold }; dp[i][do transaction][j] = max {dp[i - 1][no transaction][j] + sell, dp[i - 1][do transaction][j] + hold }; } } return dp[n-1][do transaction]; hold[i][j] = max {sold[i - 1][j - 1] + buy, hold[i - 1][j]} sold[i][j] = max {hold[i - 1][j] + sell, sold[i - 1][j]}","title":"Optimized"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#template-iii","text":"class Solution { public int maxProfit ( int k , int [] prices ) { if ( k == 0 || prices . length == 0 ) return 0 ; if ( k = prices . length / 2 ) return helper ( prices ); int n = prices . length ; int [][] hold = new int [ n ][ k + 1 ]; int [][] sold = new int [ n ][ k + 1 ]; for ( int i = 1 ; i n ; i ++) { int diff = prices [ i ] - prices [ i - 1 ]; for ( int j = 1 ; j = k ; j ++) { hold [ i ][ j ] = Math . max ( sold [ i - 1 ][ j - 1 ] + diff , hold [ i - 1 ][ j ] + diff ); sold [ i ][ j ] = Math . max ( hold [ i ][ j ], sold [ i - 1 ][ j ]); } } return sold [ n - 1 ][ k ]; } int helper ( int [] prices ) { int res = 0 ; for ( int i = 1 ; i prices . length ; i ++) { if ( prices [ i ] prices [ i - 1 ]) res += prices [ i ] - prices [ i - 1 ]; } return res ; } }","title":"Template III"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/","text":"Multiple States Description Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Question Link https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/ Example I Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example II: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Questions LeetCode - 188. Best Time to Buy and Sell Stock IV Transform Function / | dp[i][j - 1] dp[i][j] = max | | prices[j] - prices[m] + dp[i - 1][m] \\ Template I // Submission Result: Memory Limit Exceeded class Solution { public int maxProfit ( int k , int [] prices ) { if ( k == 0 || prices . length == 0 ) return 0 ; int m = k , n = prices . length ; int [][] dp = new int [ m + 1 ][ n ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 1 ; j n ; j ++) { for ( int s = 0 ; s j ; s ++) { dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i - 1 ][ s ] + prices [ j ] - prices [ s ]); } dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i ][ j - 1 ]); } } return dp [ m ][ n - 1 ]; } } Optimized hold_one[i] = Math.max(-prices[i], hold_one[i - 1]) hold_one_sell_one = Math.max(hold_one[i - 1] + prices[i], hold_one_sell_one[i - 1]) hold_two_sell_one = Math.max(hold_one_sell_one[i - 1] - prices[i], hold_two_sell_one[i - 1]) hold_two_sell_two = Math.max(hold_two_sell_one[i - 1] + prices[i], hold_two_sell_two[i - 1]) Template II class Solution { public int maxProfit ( int [] prices ) { if ( prices == null || prices . length == 0 ) return 0 ; int n = prices . length ; int [] holdOne = new int [ n + 1 ]; int [] holdOneSellOne = new int [ n + 1 ]; int [] holdTwoSellOne = new int [ n + 1 ]; int [] holdTwoSellTwo = new int [ n + 1 ]; holdOne [ 0 ] = Integer . MIN_VALUE ; holdTwoSellOne [ 0 ] = Integer . MIN_VALUE ; for ( int i = 1 ; i = n ; i ++) { holdOne [ i ] = Math . max ( holdOne [ i - 1 ], - prices [ i - 1 ]); holdOneSellOne [ i ] = Math . max ( holdOneSellOne [ i - 1 ], holdOne [ i - 1 ] + prices [ i - 1 ]); holdTwoSellOne [ i ] = Math . max ( holdTwoSellOne [ i - 1 ], holdOneSellOne [ i - 1 ] - prices [ i - 1 ]); holdTwoSellTwo [ i ] = Math . max ( holdTwoSellTwo [ i - 1 ], holdTwoSellOne [ i - 1 ] + prices [ i - 1 ]); } return holdTwoSellTwo [ n ]; } } Optimized int hold_one = Integer.MIN_VALUE; int hold_one_sell_one = 0; int hold_two_sell_one = Integer.MIN_VALUE; int hold_two_sell_two = 0; Template III class Solution { public int maxProfit ( int [] prices ) { int hold_one = Integer . MIN_VALUE , hold_one_sell_one = 0 ; int hold_two_sell_one = Integer . MIN_VALUE ; int hold_two_sell_two = 0 ; for ( int p : prices ) { hold_one = Math . max ( hold_one , - p ); hold_one_sell_one = Math . max ( hold_one + p , hold_one_sell_one ); hold_two_sell_one = Math . max ( hold_one_sell_one - p , hold_two_sell_one ); hold_two_sell_two = Math . max ( hold_two_sell_one + p , hold_two_sell_two ); } return hold_two_sell_two ; } }","title":"Multiple States IV"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#multiple-states","text":"","title":"Multiple States"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#description","text":"Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions.","title":"Description"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#question-link","text":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#example-i","text":"Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.","title":"Example I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#example-ii","text":"Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.","title":"Example II:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#questions","text":"LeetCode - 188. Best Time to Buy and Sell Stock IV","title":"Questions"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#transform-function","text":"/ | dp[i][j - 1] dp[i][j] = max | | prices[j] - prices[m] + dp[i - 1][m] \\","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#template-i","text":"// Submission Result: Memory Limit Exceeded class Solution { public int maxProfit ( int k , int [] prices ) { if ( k == 0 || prices . length == 0 ) return 0 ; int m = k , n = prices . length ; int [][] dp = new int [ m + 1 ][ n ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 1 ; j n ; j ++) { for ( int s = 0 ; s j ; s ++) { dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i - 1 ][ s ] + prices [ j ] - prices [ s ]); } dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i ][ j - 1 ]); } } return dp [ m ][ n - 1 ]; } }","title":"Template I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#optimized","text":"hold_one[i] = Math.max(-prices[i], hold_one[i - 1]) hold_one_sell_one = Math.max(hold_one[i - 1] + prices[i], hold_one_sell_one[i - 1]) hold_two_sell_one = Math.max(hold_one_sell_one[i - 1] - prices[i], hold_two_sell_one[i - 1]) hold_two_sell_two = Math.max(hold_two_sell_one[i - 1] + prices[i], hold_two_sell_two[i - 1])","title":"Optimized"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#template-ii","text":"class Solution { public int maxProfit ( int [] prices ) { if ( prices == null || prices . length == 0 ) return 0 ; int n = prices . length ; int [] holdOne = new int [ n + 1 ]; int [] holdOneSellOne = new int [ n + 1 ]; int [] holdTwoSellOne = new int [ n + 1 ]; int [] holdTwoSellTwo = new int [ n + 1 ]; holdOne [ 0 ] = Integer . MIN_VALUE ; holdTwoSellOne [ 0 ] = Integer . MIN_VALUE ; for ( int i = 1 ; i = n ; i ++) { holdOne [ i ] = Math . max ( holdOne [ i - 1 ], - prices [ i - 1 ]); holdOneSellOne [ i ] = Math . max ( holdOneSellOne [ i - 1 ], holdOne [ i - 1 ] + prices [ i - 1 ]); holdTwoSellOne [ i ] = Math . max ( holdTwoSellOne [ i - 1 ], holdOneSellOne [ i - 1 ] - prices [ i - 1 ]); holdTwoSellTwo [ i ] = Math . max ( holdTwoSellTwo [ i - 1 ], holdTwoSellOne [ i - 1 ] + prices [ i - 1 ]); } return holdTwoSellTwo [ n ]; } }","title":"Template II"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#optimized_1","text":"int hold_one = Integer.MIN_VALUE; int hold_one_sell_one = 0; int hold_two_sell_one = Integer.MIN_VALUE; int hold_two_sell_two = 0;","title":"Optimized"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#template-iii","text":"class Solution { public int maxProfit ( int [] prices ) { int hold_one = Integer . MIN_VALUE , hold_one_sell_one = 0 ; int hold_two_sell_one = Integer . MIN_VALUE ; int hold_two_sell_two = 0 ; for ( int p : prices ) { hold_one = Math . max ( hold_one , - p ); hold_one_sell_one = Math . max ( hold_one + p , hold_one_sell_one ); hold_two_sell_one = Math . max ( hold_one_sell_one - p , hold_two_sell_one ); hold_two_sell_two = Math . max ( hold_two_sell_one + p , hold_two_sell_two ); } return hold_two_sell_two ; } }","title":"Template III"},{"location":"LeetCode/lc0001/","text":"1. Two Sum Description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Java public int [] twoSum ( int [] nums , int target ) { HashMap Integer , Integer map = new HashMap (); for ( int i = 0 ; i nums . length ; i ++) { if ( map . containsKey ( target - nums [ i ]) map . get ( target - nums [ i ]) != i ) { return new int []{ map . get ( target - nums [ i ]), i }; } map . put ( nums [ i ], i ); } return new int []{}; } JavaScript var twoSum = function ( nums , target ) { var res = []; var map = new Map (); for ( var i = 0 ; i nums . length ; i ++ ) { if ( map . has ( target - nums [ i ])) { res . push ( map . get ( target - nums [ i ])); res . push ( i ); return res ; } map . set ( nums [ i ], i ); } return res ; } C++ public : vector int twoSum ( vector int nums , int target ) { unordered_map int , int map ; for ( int i = 0 ; i nums . size (); i ++ ) { if ( map . count ( target - nums [ i ])) { return { map [ target - nums [ i ]], i }; } map [ nums [ i ]] = i ; } return {}; } C struct node { int key ; int val ; int count ; struct node * next ; }; struct table { int size ; struct node ** list ; }; struct table * createTable ( int size ) { struct table * t = ( struct table * ) malloc ( sizeof ( struct table )); t - size = size ; t - list = ( struct node ** ) malloc ( sizeof ( struct node * ) * size ); for ( int i = 0 ; i size ; i ++ ) { t - list [ i ] = NULL ; } return t ; } int hashCode ( struct table * t , int key ) { if ( key 0 ) return - ( key % t - size ); return key % t - size ; } void insert ( struct table * t , int key , int val ) { int pos = hashCode ( t , key ); struct node * list = t - list [ pos ]; struct node * newNode = ( struct node * ) malloc ( sizeof ( struct node )); struct node * temp = list ; while ( temp ) { if ( temp - key == key ){ temp - count = temp - count + 1 ; return ; } temp = temp - next ; } newNode - key = key ; newNode - val = val ; newNode - count = 1 ; newNode - next = list ; t - list [ pos ] = newNode ; return ; } int search ( struct table * t , int key ) { int pos = hashCode ( t , key ); struct node * list = t - list [ pos ]; struct node * temp = list ; while ( temp ) { if ( temp - key == key ) { return temp - val ; } temp = temp - next ; } return - 1 ; } int * twoSum ( int * nums , int numsSize , int target ) { int * res = malloc ( sizeof ( int ) * 2 ); struct table * t = createTable ( numsSize ); for ( int i = 0 ; i numsSize ; i ++ ) { int pos = search ( t , target - nums [ i ]); if ( pos - 1 ) { res [ 0 ] = pos ; res [ 1 ] = i ; return res ; } insert ( t , nums [ i ], i ); } return res ; }","title":"1 Two Sum"},{"location":"LeetCode/lc0001/#1-two-sum","text":"","title":"1. Two Sum"},{"location":"LeetCode/lc0001/#description","text":"Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.","title":"Description"},{"location":"LeetCode/lc0001/#example","text":"Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].","title":"Example"},{"location":"LeetCode/lc0001/#java","text":"public int [] twoSum ( int [] nums , int target ) { HashMap Integer , Integer map = new HashMap (); for ( int i = 0 ; i nums . length ; i ++) { if ( map . containsKey ( target - nums [ i ]) map . get ( target - nums [ i ]) != i ) { return new int []{ map . get ( target - nums [ i ]), i }; } map . put ( nums [ i ], i ); } return new int []{}; }","title":"Java"},{"location":"LeetCode/lc0001/#javascript","text":"var twoSum = function ( nums , target ) { var res = []; var map = new Map (); for ( var i = 0 ; i nums . length ; i ++ ) { if ( map . has ( target - nums [ i ])) { res . push ( map . get ( target - nums [ i ])); res . push ( i ); return res ; } map . set ( nums [ i ], i ); } return res ; }","title":"JavaScript"},{"location":"LeetCode/lc0001/#c","text":"public : vector int twoSum ( vector int nums , int target ) { unordered_map int , int map ; for ( int i = 0 ; i nums . size (); i ++ ) { if ( map . count ( target - nums [ i ])) { return { map [ target - nums [ i ]], i }; } map [ nums [ i ]] = i ; } return {}; }","title":"C++"},{"location":"LeetCode/lc0001/#c_1","text":"struct node { int key ; int val ; int count ; struct node * next ; }; struct table { int size ; struct node ** list ; }; struct table * createTable ( int size ) { struct table * t = ( struct table * ) malloc ( sizeof ( struct table )); t - size = size ; t - list = ( struct node ** ) malloc ( sizeof ( struct node * ) * size ); for ( int i = 0 ; i size ; i ++ ) { t - list [ i ] = NULL ; } return t ; } int hashCode ( struct table * t , int key ) { if ( key 0 ) return - ( key % t - size ); return key % t - size ; } void insert ( struct table * t , int key , int val ) { int pos = hashCode ( t , key ); struct node * list = t - list [ pos ]; struct node * newNode = ( struct node * ) malloc ( sizeof ( struct node )); struct node * temp = list ; while ( temp ) { if ( temp - key == key ){ temp - count = temp - count + 1 ; return ; } temp = temp - next ; } newNode - key = key ; newNode - val = val ; newNode - count = 1 ; newNode - next = list ; t - list [ pos ] = newNode ; return ; } int search ( struct table * t , int key ) { int pos = hashCode ( t , key ); struct node * list = t - list [ pos ]; struct node * temp = list ; while ( temp ) { if ( temp - key == key ) { return temp - val ; } temp = temp - next ; } return - 1 ; } int * twoSum ( int * nums , int numsSize , int target ) { int * res = malloc ( sizeof ( int ) * 2 ); struct table * t = createTable ( numsSize ); for ( int i = 0 ; i numsSize ; i ++ ) { int pos = search ( t , target - nums [ i ]); if ( pos - 1 ) { res [ 0 ] = pos ; res [ 1 ] = i ; return res ; } insert ( t , nums [ i ], i ); } return res ; }","title":"C"},{"location":"LeetCode/lc0101/","text":"101. Symmetric Tree Description Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). Example For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3 Java(Recursive) public boolean isSymmetric ( TreeNode root ) { if ( root == null ) return true ; return helper ( root . left , root . right ); } boolean helper ( TreeNode left , TreeNode right ) { if ( left == null right == null ) return true ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; boolean temp = true ; return temp helper ( left . left , right . right ) helper ( left . right , right . left ); } Java(Iterative) public boolean isSymmetric ( TreeNode root ) { Queue TreeNode queue = new LinkedList (); queue . offer ( root ); queue . offer ( root ); while (! queue . isEmpty ()) { TreeNode left = queue . poll (); TreeNode right = queue . poll (); if ( left == null right == null ) continue ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; queue . offer ( left . left ); queue . offer ( right . right ); queue . offer ( left . right ); queue . offer ( right . left ); } return true ; } JavaScript var isSymmetric = function ( root ) { if ( root == null ) return true ; return helper ( root . left , root . right ); }; function helper ( left , right ) { if ( left == null right == null ) return true ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; return helper ( left . left , right . right ) helper ( left . right , right . left ); } C++ public : bool isSymmetric ( TreeNode * root ) { if ( ! root ) return true ; return helper ( root - left , root - right ); } public : bool helper ( TreeNode * left , TreeNode * right ) { if ( ! left ! right ) return true ; if ( ! left || ! right ) return false ; if ( left - val != right - val ) return false ; return helper ( left - left , right - right ) helper ( left - right , right - left ); }","title":"101 Symmetric Tree"},{"location":"LeetCode/lc0101/#101-symmetric-tree","text":"","title":"101. Symmetric Tree"},{"location":"LeetCode/lc0101/#description","text":"Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).","title":"Description"},{"location":"LeetCode/lc0101/#example","text":"For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3","title":"Example"},{"location":"LeetCode/lc0101/#javarecursive","text":"public boolean isSymmetric ( TreeNode root ) { if ( root == null ) return true ; return helper ( root . left , root . right ); } boolean helper ( TreeNode left , TreeNode right ) { if ( left == null right == null ) return true ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; boolean temp = true ; return temp helper ( left . left , right . right ) helper ( left . right , right . left ); }","title":"Java(Recursive)"},{"location":"LeetCode/lc0101/#javaiterative","text":"public boolean isSymmetric ( TreeNode root ) { Queue TreeNode queue = new LinkedList (); queue . offer ( root ); queue . offer ( root ); while (! queue . isEmpty ()) { TreeNode left = queue . poll (); TreeNode right = queue . poll (); if ( left == null right == null ) continue ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; queue . offer ( left . left ); queue . offer ( right . right ); queue . offer ( left . right ); queue . offer ( right . left ); } return true ; }","title":"Java(Iterative)"},{"location":"LeetCode/lc0101/#javascript","text":"var isSymmetric = function ( root ) { if ( root == null ) return true ; return helper ( root . left , root . right ); }; function helper ( left , right ) { if ( left == null right == null ) return true ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; return helper ( left . left , right . right ) helper ( left . right , right . left ); }","title":"JavaScript"},{"location":"LeetCode/lc0101/#c","text":"public : bool isSymmetric ( TreeNode * root ) { if ( ! root ) return true ; return helper ( root - left , root - right ); } public : bool helper ( TreeNode * left , TreeNode * right ) { if ( ! left ! right ) return true ; if ( ! left || ! right ) return false ; if ( left - val != right - val ) return false ; return helper ( left - left , right - right ) helper ( left - right , right - left ); }","title":"C++"},{"location":"LeetCode/lc0282/","text":"282. Expression Add Operators Description Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. Example 1. Input: num = 123 , target = 6 Output: [ 1+2+3 , 1*2*3 ] 2. Input: num = 232 , target = 8 Output: [ 2*3+2 , 2+3*2 ] 3. Input: num = 105 , target = 5 Output: [ 1*0+5 , 10-5 ] 4. Input: num = 00 , target = 0 Output: [ 0+0 , 0-0 , 0*0 ] 5. Input: num = 3456237490 , target = 9191 Output: [] Java public List String addOperators ( String num , int target ) { List String res = new ArrayList (); if ( num == null || num . length () == 0 ) return res ; helper ( num , , 0 , 0 , 0 , target , res ); return res ; } public void helper ( String num , String temp , int pos , long cur , long prev , int target , List String res ) { if ( pos == num . length ()) { if ( cur == target ) { res . add ( temp ); } return ; } for ( int i = pos ; i num . length (); i ++) { if ( i != pos num . charAt ( pos ) == 0 ) break ; long t = Long . parseLong ( num . substring ( pos , i + 1 )); if ( pos == 0 ) { helper ( num , temp + t , i + 1 , t , t , target , res ); } else { helper ( num , temp + + + t , i + 1 , cur + t , t , target , res ); helper ( num , temp + - + t , i + 1 , cur - t , - t , target , res ); helper ( num , temp + * + t , i + 1 , cur - prev + t * prev , t * prev , target , res ); } } } JavaScript var addOperators = function ( num , target ) { var res = []; helper ( num , , 0 , 0 , 0 , target , res ); return res ; }; function helper ( num , temp , pos , cur , prev , target , res ) { if ( pos === num . length ) { if ( cur === target ) { res . push ( temp ); } return ; } for ( let i = pos ; i num . length ; i ++ ) { if ( i != pos num . charAt ( pos ) == 0 ) break ; let n = parseInt ( num . substring ( pos , i + 1 )); if ( pos == 0 ) { helper ( num , + n , i + 1 , n , n , target , res ); } else { helper ( num , temp + + + n , i + 1 , cur + n , n , target , res ); helper ( num , temp + - + n , i + 1 , cur - n , - n , target , res ); helper ( num , temp + * + n , i + 1 , cur - prev + n * prev , n * prev , target , res ); } } } C++ public : vector string addOperators ( string num , int target ) { vector string res ; helper ( num , , 0 , 0 , 0 , target , res ); return res ; } private : void helper ( string num , string temp , int pos , long cur , long prev , int target , vector string res ) { if ( pos == num . size ()) { if ( cur == target ) { res . push_back ( temp ); } return ; } for ( int i = pos ; i num . size (); i ++ ) { if ( i != pos num [ pos ] == 0 ) break ; string n = num . substr ( pos , i - pos + 1 ); if ( pos == 0 ) { helper ( num , + n , i + 1 , stoll ( n ), stoll ( n ), target , res ); } else { helper ( num , temp + + + n , i + 1 , cur + stoll ( n ), stoll ( n ), target , res ); helper ( num , temp + - + n , i + 1 , cur - stoll ( n ), - stoll ( n ), target , res ); helper ( num , temp + * + n , i + 1 , cur - prev + prev * stoll ( n ), prev * stoll ( n ), target , res ); } } }","title":"282 Expression Add Operators"},{"location":"LeetCode/lc0282/#282-expression-add-operators","text":"","title":"282. Expression Add Operators"},{"location":"LeetCode/lc0282/#description","text":"Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.","title":"Description"},{"location":"LeetCode/lc0282/#example","text":"1. Input: num = 123 , target = 6 Output: [ 1+2+3 , 1*2*3 ] 2. Input: num = 232 , target = 8 Output: [ 2*3+2 , 2+3*2 ] 3. Input: num = 105 , target = 5 Output: [ 1*0+5 , 10-5 ] 4. Input: num = 00 , target = 0 Output: [ 0+0 , 0-0 , 0*0 ] 5. Input: num = 3456237490 , target = 9191 Output: []","title":"Example"},{"location":"LeetCode/lc0282/#java","text":"public List String addOperators ( String num , int target ) { List String res = new ArrayList (); if ( num == null || num . length () == 0 ) return res ; helper ( num , , 0 , 0 , 0 , target , res ); return res ; } public void helper ( String num , String temp , int pos , long cur , long prev , int target , List String res ) { if ( pos == num . length ()) { if ( cur == target ) { res . add ( temp ); } return ; } for ( int i = pos ; i num . length (); i ++) { if ( i != pos num . charAt ( pos ) == 0 ) break ; long t = Long . parseLong ( num . substring ( pos , i + 1 )); if ( pos == 0 ) { helper ( num , temp + t , i + 1 , t , t , target , res ); } else { helper ( num , temp + + + t , i + 1 , cur + t , t , target , res ); helper ( num , temp + - + t , i + 1 , cur - t , - t , target , res ); helper ( num , temp + * + t , i + 1 , cur - prev + t * prev , t * prev , target , res ); } } }","title":"Java"},{"location":"LeetCode/lc0282/#javascript","text":"var addOperators = function ( num , target ) { var res = []; helper ( num , , 0 , 0 , 0 , target , res ); return res ; }; function helper ( num , temp , pos , cur , prev , target , res ) { if ( pos === num . length ) { if ( cur === target ) { res . push ( temp ); } return ; } for ( let i = pos ; i num . length ; i ++ ) { if ( i != pos num . charAt ( pos ) == 0 ) break ; let n = parseInt ( num . substring ( pos , i + 1 )); if ( pos == 0 ) { helper ( num , + n , i + 1 , n , n , target , res ); } else { helper ( num , temp + + + n , i + 1 , cur + n , n , target , res ); helper ( num , temp + - + n , i + 1 , cur - n , - n , target , res ); helper ( num , temp + * + n , i + 1 , cur - prev + n * prev , n * prev , target , res ); } } }","title":"JavaScript"},{"location":"LeetCode/lc0282/#c","text":"public : vector string addOperators ( string num , int target ) { vector string res ; helper ( num , , 0 , 0 , 0 , target , res ); return res ; } private : void helper ( string num , string temp , int pos , long cur , long prev , int target , vector string res ) { if ( pos == num . size ()) { if ( cur == target ) { res . push_back ( temp ); } return ; } for ( int i = pos ; i num . size (); i ++ ) { if ( i != pos num [ pos ] == 0 ) break ; string n = num . substr ( pos , i - pos + 1 ); if ( pos == 0 ) { helper ( num , + n , i + 1 , stoll ( n ), stoll ( n ), target , res ); } else { helper ( num , temp + + + n , i + 1 , cur + stoll ( n ), stoll ( n ), target , res ); helper ( num , temp + - + n , i + 1 , cur - stoll ( n ), - stoll ( n ), target , res ); helper ( num , temp + * + n , i + 1 , cur - prev + prev * stoll ( n ), prev * stoll ( n ), target , res ); } } }","title":"C++"},{"location":"LeetCode/lc0339/","text":"399. Evaluate Division Description Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0. Example Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . return [6.0, 0.5, -1.0, 1.0, -1.0 ]. The input is: vector equations, vector values, vector queries ,where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector . According to the example above: equations = [ [ a , b ], [ b , c ] ], values = [2.0, 3.0], queries = [ [ a , c ], [ b , a ], [ a , e ], [ a , a ], [ x , x ] ]. Java(DFS) Map String , Map String , Double map ; public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { map = new HashMap (); for ( int i = 0 ; i equations . length ; i ++) { String x = equations [ i ][ 0 ]; String y = equations [ i ][ 1 ]; double value = values [ i ]; map . putIfAbsent ( x , new HashMap String , Double ()); map . putIfAbsent ( y , new HashMap String , Double ()); map . get ( x ). put ( y , value ); map . get ( y ). put ( x , 1.0 / value ); } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { if (! map . containsKey ( queries [ i ][ 0 ]) || ! map . containsKey ( queries [ i ][ 0 ])) res [ i ] = - 1.0 ; else res [ i ] = dfs ( queries [ i ][ 0 ], queries [ i ][ 1 ], new HashSet String ()); } return res ; } double dfs ( String cur , String target , Set String set ) { if ( cur . equals ( target )) return 1.0 ; set . add ( cur ); if (! map . containsKey ( cur )) return - 1.0 ; for ( String neighbor : map . get ( cur ). keySet ()) { if ( set . contains ( neighbor )) continue ; double t = dfs ( neighbor , target , set ); if ( t - 1.0 ) return t * map . get ( cur ). get ( neighbor ); } return - 1.0 ; } Java(Union Find) class Node { String parent ; double ratio ; Node ( String parent , double ratio ) { this . parent = parent ; this . ratio = ratio ; } } class UnionFindSet { Map String , Node parents = new HashMap (); Node find ( String s ) { if (! parents . containsKey ( s )) return null ; Node n = parents . get ( s ); if (! n . parent . equals ( s )) { Node t = find ( n . parent ); n . parent = t . parent ; n . ratio *= t . ratio ; } return n ; } void union ( String s , String p , double ratio ) { boolean hasS = parents . containsKey ( s ); boolean hasP = parents . containsKey ( p ); if (! hasS ! hasP ) { parents . put ( s , new Node ( p , ratio )); parents . put ( p , new Node ( p , 1.0 )); } else if (! hasP ){ parents . put ( p , new Node ( s , 1.0 / ratio )); } else if (! hasS ) { parents . put ( s , new Node ( p , ratio )); } else { Node pS = find ( s ); Node pP = find ( p ); pS . parent = pP . parent ; pS . ratio = ratio / pS . ratio * pP . ratio ; } } } public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { UnionFindSet uf = new UnionFindSet (); for ( int i = 0 ; i equations . length ; i ++) { uf . union ( equations [ i ][ 0 ], equations [ i ][ 1 ], values [ i ]); } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { Node root_x = uf . find ( queries [ i ][ 0 ]), root_y = uf . find ( queries [ i ][ 1 ]); if ( root_x == null || root_y == null || ! root_x . parent . equals ( root_y . parent )) res [ i ] = - 1.0 ; else res [ i ] = root_x . ratio / root_y . ratio ; } return res ; } Java(Floyd Warshall Algorithm) public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { HashMap String , HashMap String , Double graph = new HashMap (); for ( int i = 0 ; i equations . length ; i ++) { graph . computeIfAbsent ( equations [ i ][ 0 ], f - new HashMap ()). put ( equations [ i ][ 1 ], values [ i ]); graph . computeIfAbsent ( equations [ i ][ 1 ], f - new HashMap ()). put ( equations [ i ][ 0 ], 1.0 / values [ i ]); } for ( String mid : graph . keySet ()) { for ( String src : graph . get ( mid ). keySet ()) { for ( String dest : graph . get ( mid ). keySet ()) { double val = graph . get ( src ). get ( mid ) * graph . get ( mid ). get ( dest ); graph . get ( src ). put ( dest , val ); } } } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { if (! graph . containsKey ( queries [ i ][ 0 ])) res [ i ] = - 1.0 ; else res [ i ] = graph . get ( queries [ i ][ 0 ]). getOrDefault ( queries [ i ][ 1 ], - 1.0 ); } return res ; } JavaScript var calcEquation = function ( equations , values , queries ) { var map = new Map (), valueMap = new Map (); for ( let i = 0 ; i equations . length ; i ++ ) { let x = equations [ i ][ 0 ]; let y = equations [ i ][ 1 ]; let v = values [ i ]; if ( ! map . has ( x )) { map . set ( x , []); valueMap . set ( x , []) } if ( ! map . has ( y )) { map . set ( y , []); valueMap . set ( y , []); } map . get ( x ). push ( y ); map . get ( y ). push ( x ); valueMap . get ( x ). push ( v ); valueMap . get ( y ). push ( 1.0 / v ); } var res = []; for ( let j = 0 ; j queries . length ; j ++ ) { let x = queries [ j ][ 0 ]; let y = queries [ j ][ 1 ]; if ( ! map . has ( x ) || ! map . has ( y )) { res . push ( - 1.0 ); continue ; } res . push ( dfs ( x , y , map , valueMap , new Set ())); } return res ; }; function dfs ( x , y , map , valueMap , set ) { if ( x === y ) return 1.0 ; set . add ( x ); let nextList = map . get ( x ); let valueList = valueMap . get ( x ); for ( let i = 0 ; i nextList . length ; i ++ ) { if ( set . has ( nextList [ i ])) continue ; let t = dfs ( nextList [ i ], y , map , valueMap , set ); if ( t - 1.0 ) return valueList [ i ] * t ; } return - 1.0 ; } C++(DFS) public : vector double calcEquation ( vector pair string , string equations , vector double values , vector pair string , string queries ) { unordered_map string , unordered_map string , double map ; for ( int i = 0 ; i equations . size (); i ++ ) { const string x = equations [ i ]. first ; const string y = equations [ i ]. second ; const double v = values [ i ]; map [ x ][ y ] = v ; map [ y ][ x ] = 1.0 / v ; } vector double res ; for ( const auto pair : queries ) { const string x = pair . first ; const string y = pair . second ; if ( ! map . count ( x ) || ! map . count ( y )) { res . push_back ( - 1.0 ); continue ; } else { unordered_set string set ; res . push_back ( dfs ( x , y , map , set )); } } return res ; } private : double dfs ( const string x , const string y , unordered_map string , unordered_map string , double map , unordered_set string set ) { if ( x == y ) return 1.0 ; set . insert ( x ); for ( const auto pair : map [ x ]) { const string next = pair . first ; if ( set . count ( next )) continue ; double t = dfs ( next , y , map , set ); if ( t - 1.0 ) return map [ x ][ next ] * t ; } return - 1.0 ; } C++(Union Find) public : vector double calcEquation ( vector pair string , string equations , vector double values , vector pair string , string queries ) { unordered_map string , pair string , double parents ; for ( int i = 0 ; i equations . size (); i ++ ) { const string x = equations [ i ]. first ; const string y = equations [ i ]. second ; const double v = values [ i ]; if ( ! parents . count ( x ) ! parents . count ( y )) { parents [ x ] = { y , v }; parents [ y ] = { y , 1.0 }; } else if ( ! parents . count ( y )) { parents [ y ] = { x , 1.0 / v }; } else if ( ! parents . count ( x )) { parents [ x ] = { y , v }; } else { const auto root_x = find ( x , parents ); const auto root_y = find ( y , parents ); parents [ root_x . first ] = { root_y . first , v / root_x . second * root_y . second }; } } vector double res ; for ( const auto pair : queries ) { const string x = pair . first ; const string y = pair . second ; if ( ! parents . count ( x ) || ! parents . count ( y )) { res . push_back ( - 1.0 ); continue ; } auto root_x = find ( x , parents ); auto root_y = find ( y , parents ); if ( root_x . first != root_y . first ) { res . push_back ( - 1.0 ); } else { res . push_back ( root_x . second / root_y . second ); } } return res ; } private : pair string , double find ( const string n , unordered_map string , pair string , double parents ) { if ( n != parents [ n ]. first ) { const auto p = find ( parents [ n ]. first , parents ); parents [ n ]. first = p . first ; parents [ n ]. second *= p . second ; } return parents [ n ]; }","title":"399 Evaluate Division"},{"location":"LeetCode/lc0339/#399-evaluate-division","text":"","title":"399. Evaluate Division"},{"location":"LeetCode/lc0339/#description","text":"Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.","title":"Description"},{"location":"LeetCode/lc0339/#example","text":"Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . return [6.0, 0.5, -1.0, 1.0, -1.0 ]. The input is: vector equations, vector values, vector queries ,where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector . According to the example above: equations = [ [ a , b ], [ b , c ] ], values = [2.0, 3.0], queries = [ [ a , c ], [ b , a ], [ a , e ], [ a , a ], [ x , x ] ].","title":"Example"},{"location":"LeetCode/lc0339/#javadfs","text":"Map String , Map String , Double map ; public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { map = new HashMap (); for ( int i = 0 ; i equations . length ; i ++) { String x = equations [ i ][ 0 ]; String y = equations [ i ][ 1 ]; double value = values [ i ]; map . putIfAbsent ( x , new HashMap String , Double ()); map . putIfAbsent ( y , new HashMap String , Double ()); map . get ( x ). put ( y , value ); map . get ( y ). put ( x , 1.0 / value ); } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { if (! map . containsKey ( queries [ i ][ 0 ]) || ! map . containsKey ( queries [ i ][ 0 ])) res [ i ] = - 1.0 ; else res [ i ] = dfs ( queries [ i ][ 0 ], queries [ i ][ 1 ], new HashSet String ()); } return res ; } double dfs ( String cur , String target , Set String set ) { if ( cur . equals ( target )) return 1.0 ; set . add ( cur ); if (! map . containsKey ( cur )) return - 1.0 ; for ( String neighbor : map . get ( cur ). keySet ()) { if ( set . contains ( neighbor )) continue ; double t = dfs ( neighbor , target , set ); if ( t - 1.0 ) return t * map . get ( cur ). get ( neighbor ); } return - 1.0 ; }","title":"Java(DFS)"},{"location":"LeetCode/lc0339/#javaunion-find","text":"class Node { String parent ; double ratio ; Node ( String parent , double ratio ) { this . parent = parent ; this . ratio = ratio ; } } class UnionFindSet { Map String , Node parents = new HashMap (); Node find ( String s ) { if (! parents . containsKey ( s )) return null ; Node n = parents . get ( s ); if (! n . parent . equals ( s )) { Node t = find ( n . parent ); n . parent = t . parent ; n . ratio *= t . ratio ; } return n ; } void union ( String s , String p , double ratio ) { boolean hasS = parents . containsKey ( s ); boolean hasP = parents . containsKey ( p ); if (! hasS ! hasP ) { parents . put ( s , new Node ( p , ratio )); parents . put ( p , new Node ( p , 1.0 )); } else if (! hasP ){ parents . put ( p , new Node ( s , 1.0 / ratio )); } else if (! hasS ) { parents . put ( s , new Node ( p , ratio )); } else { Node pS = find ( s ); Node pP = find ( p ); pS . parent = pP . parent ; pS . ratio = ratio / pS . ratio * pP . ratio ; } } } public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { UnionFindSet uf = new UnionFindSet (); for ( int i = 0 ; i equations . length ; i ++) { uf . union ( equations [ i ][ 0 ], equations [ i ][ 1 ], values [ i ]); } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { Node root_x = uf . find ( queries [ i ][ 0 ]), root_y = uf . find ( queries [ i ][ 1 ]); if ( root_x == null || root_y == null || ! root_x . parent . equals ( root_y . parent )) res [ i ] = - 1.0 ; else res [ i ] = root_x . ratio / root_y . ratio ; } return res ; }","title":"Java(Union Find)"},{"location":"LeetCode/lc0339/#javafloyd-warshall-algorithm","text":"public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { HashMap String , HashMap String , Double graph = new HashMap (); for ( int i = 0 ; i equations . length ; i ++) { graph . computeIfAbsent ( equations [ i ][ 0 ], f - new HashMap ()). put ( equations [ i ][ 1 ], values [ i ]); graph . computeIfAbsent ( equations [ i ][ 1 ], f - new HashMap ()). put ( equations [ i ][ 0 ], 1.0 / values [ i ]); } for ( String mid : graph . keySet ()) { for ( String src : graph . get ( mid ). keySet ()) { for ( String dest : graph . get ( mid ). keySet ()) { double val = graph . get ( src ). get ( mid ) * graph . get ( mid ). get ( dest ); graph . get ( src ). put ( dest , val ); } } } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { if (! graph . containsKey ( queries [ i ][ 0 ])) res [ i ] = - 1.0 ; else res [ i ] = graph . get ( queries [ i ][ 0 ]). getOrDefault ( queries [ i ][ 1 ], - 1.0 ); } return res ; }","title":"Java(Floyd Warshall Algorithm)"},{"location":"LeetCode/lc0339/#javascript","text":"var calcEquation = function ( equations , values , queries ) { var map = new Map (), valueMap = new Map (); for ( let i = 0 ; i equations . length ; i ++ ) { let x = equations [ i ][ 0 ]; let y = equations [ i ][ 1 ]; let v = values [ i ]; if ( ! map . has ( x )) { map . set ( x , []); valueMap . set ( x , []) } if ( ! map . has ( y )) { map . set ( y , []); valueMap . set ( y , []); } map . get ( x ). push ( y ); map . get ( y ). push ( x ); valueMap . get ( x ). push ( v ); valueMap . get ( y ). push ( 1.0 / v ); } var res = []; for ( let j = 0 ; j queries . length ; j ++ ) { let x = queries [ j ][ 0 ]; let y = queries [ j ][ 1 ]; if ( ! map . has ( x ) || ! map . has ( y )) { res . push ( - 1.0 ); continue ; } res . push ( dfs ( x , y , map , valueMap , new Set ())); } return res ; }; function dfs ( x , y , map , valueMap , set ) { if ( x === y ) return 1.0 ; set . add ( x ); let nextList = map . get ( x ); let valueList = valueMap . get ( x ); for ( let i = 0 ; i nextList . length ; i ++ ) { if ( set . has ( nextList [ i ])) continue ; let t = dfs ( nextList [ i ], y , map , valueMap , set ); if ( t - 1.0 ) return valueList [ i ] * t ; } return - 1.0 ; }","title":"JavaScript"},{"location":"LeetCode/lc0339/#cdfs","text":"public : vector double calcEquation ( vector pair string , string equations , vector double values , vector pair string , string queries ) { unordered_map string , unordered_map string , double map ; for ( int i = 0 ; i equations . size (); i ++ ) { const string x = equations [ i ]. first ; const string y = equations [ i ]. second ; const double v = values [ i ]; map [ x ][ y ] = v ; map [ y ][ x ] = 1.0 / v ; } vector double res ; for ( const auto pair : queries ) { const string x = pair . first ; const string y = pair . second ; if ( ! map . count ( x ) || ! map . count ( y )) { res . push_back ( - 1.0 ); continue ; } else { unordered_set string set ; res . push_back ( dfs ( x , y , map , set )); } } return res ; } private : double dfs ( const string x , const string y , unordered_map string , unordered_map string , double map , unordered_set string set ) { if ( x == y ) return 1.0 ; set . insert ( x ); for ( const auto pair : map [ x ]) { const string next = pair . first ; if ( set . count ( next )) continue ; double t = dfs ( next , y , map , set ); if ( t - 1.0 ) return map [ x ][ next ] * t ; } return - 1.0 ; }","title":"C++(DFS)"},{"location":"LeetCode/lc0339/#cunion-find","text":"public : vector double calcEquation ( vector pair string , string equations , vector double values , vector pair string , string queries ) { unordered_map string , pair string , double parents ; for ( int i = 0 ; i equations . size (); i ++ ) { const string x = equations [ i ]. first ; const string y = equations [ i ]. second ; const double v = values [ i ]; if ( ! parents . count ( x ) ! parents . count ( y )) { parents [ x ] = { y , v }; parents [ y ] = { y , 1.0 }; } else if ( ! parents . count ( y )) { parents [ y ] = { x , 1.0 / v }; } else if ( ! parents . count ( x )) { parents [ x ] = { y , v }; } else { const auto root_x = find ( x , parents ); const auto root_y = find ( y , parents ); parents [ root_x . first ] = { root_y . first , v / root_x . second * root_y . second }; } } vector double res ; for ( const auto pair : queries ) { const string x = pair . first ; const string y = pair . second ; if ( ! parents . count ( x ) || ! parents . count ( y )) { res . push_back ( - 1.0 ); continue ; } auto root_x = find ( x , parents ); auto root_y = find ( y , parents ); if ( root_x . first != root_y . first ) { res . push_back ( - 1.0 ); } else { res . push_back ( root_x . second / root_y . second ); } } return res ; } private : pair string , double find ( const string n , unordered_map string , pair string , double parents ) { if ( n != parents [ n ]. first ) { const auto p = find ( parents [ n ]. first , parents ); parents [ n ]. first = p . first ; parents [ n ]. second *= p . second ; } return parents [ n ]; }","title":"C++(Union Find)"}]}