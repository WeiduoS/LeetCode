{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Preface"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/","text":"1. Backpack 0-1 knapsack problem Description Given n items with size Ai, an integer m denotes the size of a backpack. How full you can fill this backpack? Question Link https://www.lintcode.com/problem/backpack/description Example I Input: [3,4,8,5], backpack size=10 Output: 9 Example II: Input: [2,3,5,7], backpack size=12 Output: 12 Questions LintCode - 92. Backpack Analysis Weight Limit(i) 0 1 2 3 4 5 6 7 8 9 10 11 w1 = 2 0 0 2 2 2 2 2 2 2 2 2 2 w2 = 3 0 0 2 3 3 5 5 5 5 5 5 5 w3 = 5 0 0 2 3 3 5 5 7 8 8 10 10 w4 = 7 0 0 2 3 3 5 5 7 8 9 10 10 Transform Function dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - wt[i - 1]] + wt[i - 1]) Template class Solution { public int backpack ( int w , int [] wt ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { if ( j = wt [ i - 1 ]) { dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ], dp [ i - 1 ][ j - wt [ i - 1 ]] + wt [ i - 1 ]); } else { dp [ i ][ j ] = dp [ i - 1 ][ j ]; } } } return dp [ n ][ w ]; } } Optimize class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [] dp = new int [ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = w ; j = 0 ; j --) { if ( j = wt [ i - 1 ]) { dp [ j ] = Math . max ( dp [ j ], dp [ j - wt [ i - 1 ]] + wt [ i - 1 ]); } } } return dp [ w ]; } }","title":"Backpack I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#1-backpack-0-1-knapsack-problem","text":"","title":"1. Backpack 0-1 knapsack problem"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#description","text":"Given n items with size Ai, an integer m denotes the size of a backpack. How full you can fill this backpack?","title":"Description"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#question-link","text":"https://www.lintcode.com/problem/backpack/description","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#example-i","text":"Input: [3,4,8,5], backpack size=10 Output: 9","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#example-ii","text":"Input: [2,3,5,7], backpack size=12 Output: 12","title":"Example II:"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#questions","text":"LintCode - 92. Backpack","title":"Questions"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#analysis","text":"Weight Limit(i) 0 1 2 3 4 5 6 7 8 9 10 11 w1 = 2 0 0 2 2 2 2 2 2 2 2 2 2 w2 = 3 0 0 2 3 3 5 5 5 5 5 5 5 w3 = 5 0 0 2 3 3 5 5 7 8 8 10 10 w4 = 7 0 0 2 3 3 5 5 7 8 9 10 10","title":"Analysis"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#transform-function","text":"dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - wt[i - 1]] + wt[i - 1])","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#template","text":"class Solution { public int backpack ( int w , int [] wt ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { if ( j = wt [ i - 1 ]) { dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ], dp [ i - 1 ][ j - wt [ i - 1 ]] + wt [ i - 1 ]); } else { dp [ i ][ j ] = dp [ i - 1 ][ j ]; } } } return dp [ n ][ w ]; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack01/#optimize","text":"class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [] dp = new int [ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = w ; j = 0 ; j --) { if ( j = wt [ i - 1 ]) { dp [ j ] = Math . max ( dp [ j ], dp [ j - wt [ i - 1 ]] + wt [ i - 1 ]); } } } return dp [ w ]; } }","title":"Optimize"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/","text":"2. Backpack 0-1 knapsack problem Description There are n items and a backpack with size m. Given array A representing the size of each item and array V representing the value of each item. Example I Input: m = 10, A = [2, 3, 5, 7], V = [1, 5, 2, 4] Output: 9 Explanation: Put A[1] and A[3] into backpack, getting the maximum value V[1] + V[3] = 9 Example II Input: m = 10, A = [2, 3, 8], V = [2, 5, 8] Output: 10 Explanation: Put A[0] and A[2] into backpack, getting the maximum value V[0] + V[2] = 10 Questions LintCode - 125. Backpack II Analysis Weight / Value (i) 0 1 2 3 4 5 6 7 8 9 10 11 w1 = 1 v1 = 1 0 1 1 1 1 1 1 1 1 1 1 1 w2 = 2 v2 = 6 0 1 6 7 7 7 7 7 7 7 7 7 w3 = 5 v3 = 18 0 1 6 7 7 18 19 24 25 25 25 25 w4 = 6 v3 = 22 0 1 6 7 7 18 22 24 28 29 29 40 w5 = 7 v5 = 28 0 1 6 7 7 18 22 28 29 34 35 40 Transform Function dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - wt[i - 1]] + val[i - 1]) Template class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { if ( j = wt [ i - 1 ]) { dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ], dp [ i ][ j - wt [ i - 1 ]] + val [ i - 1 ]); } else { dp [ i ][ j ] = dp [ i - 1 ][ j ]; } } } return dp [ n ][ w ]; } } Optimize class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [] dp = new int [ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = w ; j = 0 ; j --) { if ( j = wt [ i - 1 ]) { dp [ j ] = Math . max ( dp [ j ], dp [ j - wt [ i - 1 ]] + val [ i - 1 ]); } } } return dp [ w ]; } }","title":"Backpack II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#2-backpack-0-1-knapsack-problem","text":"","title":"2. Backpack 0-1 knapsack problem"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#description","text":"There are n items and a backpack with size m. Given array A representing the size of each item and array V representing the value of each item.","title":"Description"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#example-i","text":"Input: m = 10, A = [2, 3, 5, 7], V = [1, 5, 2, 4] Output: 9 Explanation: Put A[1] and A[3] into backpack, getting the maximum value V[1] + V[3] = 9","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#example-ii","text":"Input: m = 10, A = [2, 3, 8], V = [2, 5, 8] Output: 10 Explanation: Put A[0] and A[2] into backpack, getting the maximum value V[0] + V[2] = 10","title":"Example II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#questions","text":"LintCode - 125. Backpack II","title":"Questions"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#analysis","text":"Weight / Value (i) 0 1 2 3 4 5 6 7 8 9 10 11 w1 = 1 v1 = 1 0 1 1 1 1 1 1 1 1 1 1 1 w2 = 2 v2 = 6 0 1 6 7 7 7 7 7 7 7 7 7 w3 = 5 v3 = 18 0 1 6 7 7 18 19 24 25 25 25 25 w4 = 6 v3 = 22 0 1 6 7 7 18 22 24 28 29 29 40 w5 = 7 v5 = 28 0 1 6 7 7 18 22 28 29 34 35 40","title":"Analysis"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#transform-function","text":"dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - wt[i - 1]] + val[i - 1])","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#template","text":"class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { if ( j = wt [ i - 1 ]) { dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ], dp [ i ][ j - wt [ i - 1 ]] + val [ i - 1 ]); } else { dp [ i ][ j ] = dp [ i - 1 ][ j ]; } } } return dp [ n ][ w ]; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack02/#optimize","text":"class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [] dp = new int [ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = w ; j = 0 ; j --) { if ( j = wt [ i - 1 ]) { dp [ j ] = Math . max ( dp [ j ], dp [ j - wt [ i - 1 ]] + val [ i - 1 ]); } } } return dp [ w ]; } }","title":"Optimize"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/","text":"3. Backpack unbounded knapsack problem (UKP) Description Given n items with size wt_i and value v_i (i : 0 ~ n - 1), an integer W denotes the size of a backpack. Each item you can pick multiple times, How full you can fill this backpack to maximize the total value? Example I Input: A = [2, 3, 5, 7], V = [1, 5, 2, 4], m = 10 Output: 15 Explanation: Put three item 1 (A[1] = 3, V[1] = 5) into backpack. Example II Input: A = [1, 2, 3], V = [1, 2, 3], m = 5 Output: 5 Explanation: Strategy is not unique. For example, put five item 0 (A[0] = 1, V[0] = 1) into backpack. Question LintCode - 440. Backpack III Analysis Weight Limit(i) 0 1 2 3 4 5 6 7 8 9 10 w1 = 2 v1 = 1 0 0 1 1 2 2 3 3 4 4 5 w2 = 3 v2 = 5 0 0 1 5 5 6 10 10 11 15 15 w3 = 5 v3 = 2 0 0 1 5 5 6 10 10 11 15 15 w4 = 7 v4 = 4 0 0 1 5 5 6 10 10 11 15 15 Transform Function dp[i][j] = Math.max(dp[i - 1][j - k * wt[i - 1]] + k * val[i - 1] | k = 0) Template class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { for ( int k = 0 ; k * wt [ i - 1 ] = j ; k ++) { dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i - 1 ][ j - k * wt [ i - 1 ]] + k * val [ i - 1 ]); } } } return dp [ n ][ w ]; } } Optimize Transform Function dp[i][j] = Math.max(dp[i - 1][j - k * wt[i - 1]] + k * val[i - 1] | k = 0) dp[i][j] = Math.max(dp[i - 1][j], max{dp[i - 1][j - k * wt[i - 1] + k * val[i - 1] | k = 1} dp[i][j] = Math.max(dp[i - 1][j], max{dp[i - 1][(j - w[i - 1]) - k * wt[i - 1] + k * val[i - 1] | k = 0} + val[i - 1]} dp[i][j] = Math.max(dp[i - 1][j], max{dp[i][j - w[i - 1] + val[i - 1]} Optimize I class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { if ( j wt [ i - 1 ]) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; } else { dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ], dp [ i ][ j - wt [ i - 1 ]] + val [ i - 1 ]); } } } return dp [ n ][ w ]; } } Optimize II class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [] dp = new int [ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = wt [ i - 1 ]; j = w ; j ++) { dp [ j ] = Math . max ( dp [ j ], dp [ j - wt [ i - 1 ]] + val [ i - 1 ]); } } return dp [ w ]; } }","title":"Backpack III"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#3-backpack-unbounded-knapsack-problem-ukp","text":"","title":"3. Backpack unbounded knapsack problem (UKP)"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#description","text":"Given n items with size wt_i and value v_i (i : 0 ~ n - 1), an integer W denotes the size of a backpack. Each item you can pick multiple times, How full you can fill this backpack to maximize the total value?","title":"Description"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#example-i","text":"Input: A = [2, 3, 5, 7], V = [1, 5, 2, 4], m = 10 Output: 15 Explanation: Put three item 1 (A[1] = 3, V[1] = 5) into backpack.","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#example-ii","text":"Input: A = [1, 2, 3], V = [1, 2, 3], m = 5 Output: 5 Explanation: Strategy is not unique. For example, put five item 0 (A[0] = 1, V[0] = 1) into backpack.","title":"Example II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#question","text":"LintCode - 440. Backpack III","title":"Question"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#analysis","text":"Weight Limit(i) 0 1 2 3 4 5 6 7 8 9 10 w1 = 2 v1 = 1 0 0 1 1 2 2 3 3 4 4 5 w2 = 3 v2 = 5 0 0 1 5 5 6 10 10 11 15 15 w3 = 5 v3 = 2 0 0 1 5 5 6 10 10 11 15 15 w4 = 7 v4 = 4 0 0 1 5 5 6 10 10 11 15 15","title":"Analysis"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#transform-function","text":"dp[i][j] = Math.max(dp[i - 1][j - k * wt[i - 1]] + k * val[i - 1] | k = 0)","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#template","text":"class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { for ( int k = 0 ; k * wt [ i - 1 ] = j ; k ++) { dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i - 1 ][ j - k * wt [ i - 1 ]] + k * val [ i - 1 ]); } } } return dp [ n ][ w ]; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#optimize-transform-function","text":"dp[i][j] = Math.max(dp[i - 1][j - k * wt[i - 1]] + k * val[i - 1] | k = 0) dp[i][j] = Math.max(dp[i - 1][j], max{dp[i - 1][j - k * wt[i - 1] + k * val[i - 1] | k = 1} dp[i][j] = Math.max(dp[i - 1][j], max{dp[i - 1][(j - w[i - 1]) - k * wt[i - 1] + k * val[i - 1] | k = 0} + val[i - 1]} dp[i][j] = Math.max(dp[i - 1][j], max{dp[i][j - w[i - 1] + val[i - 1]}","title":"Optimize Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#optimize-i","text":"class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [][] dp = new int [ n + 1 ][ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = w ; j ++) { if ( j wt [ i - 1 ]) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; } else { dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ], dp [ i ][ j - wt [ i - 1 ]] + val [ i - 1 ]); } } } return dp [ n ][ w ]; } }","title":"Optimize I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack03/#optimize-ii","text":"class Solution { public int backpack ( int w , int [] wt , int [] val ) { int n = wt . length ; int [] dp = new int [ w + 1 ]; for ( int i = 1 ; i = n ; i ++) { for ( int j = wt [ i - 1 ]; j = w ; j ++) { dp [ j ] = Math . max ( dp [ j ], dp [ j - wt [ i - 1 ]] + val [ i - 1 ]); } } return dp [ w ]; } }","title":"Optimize II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/","text":"4. Backpack bounded knapsack problem (BKP) Description Assume that you have n yuan. There are many kinds of rice in the supermarket. Each kind of rice is bagged and must be purchased in the whole bag. Given the weight, price and quantity of each type of rice, find the maximum weight of rice that you can purchase. Example I Input: n = 8, prices = [3,2], weights = [300,160], amounts = [1,6] Output: 640 Explanation: Buy the second rice(price = 2) use all 8 money. Example II Input: n = 8, prices = [2,4], weight = [100,100], amounts = [4,2 ] Output: 400 Explanation: Buy the first rice(price = 2) use all 8 money. Question LintCode - 798. Backpack VII Transform Function dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k * prices[i - 1]] + k * weight[i - 1]); Template class Solution { public int backpack ( int n , int [] prices , int [] weight , int [] amounts ) { int m = prices . length ; int [][] dp = new int [ m + 1 ][ n + 1 ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 1 ; j = n ; j ++) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; for ( int k = 1 ; k = amounts [ i - 1 ] k * prices [ i - 1 ] = j ; k ++) { dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i - 1 ][ j - k * prices [ i - 1 ]] + k * weight [ i - 1 ]); } } } return dp [ m ][ n ]; } } Another Template class Solution { public int backpack ( int n , int [] prices , int [] weight , int [] amounts ) { int m = prices . length ; int [][] dp = new int [ m + 1 ][ n + 1 ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = amounts [ i - 1 ]; j ++) { for ( int k = 1 ; k = n ; k ++) { if ( k = j * prices [ i - 1 ]) dp [ i ][ k ] = Math . max ( dp [ i ][ k ], dp [ i - 1 ][ k - j * prices [ i - 1 ]] + j * weight [ i - 1 ]); } } } return dp [ m ][ n ]; } } Optimize Analysis Wrong Answer: for (int i = 1; i = n; ++i) { for (int j = 1; j = amounts[i - 1]; ++j) { for (int k = n; k = j * prices[i - 1]; --k) { dp[k] = max(dp[k], dp[k - j * prices[i - 1]] + j * weight[i - 1]); } } } 1. dp[i - 1][k - j * prices[i - 1]] + j * weight[i - 1])\uff0c j = 0\u2026amounts[i-1] Max(dp[i][j], dp[i - 1][j]) 2. dp[k - prices[i - 1]] + weight[i - 1] (j = 1) is the max because k is from max to 1 so dp[k - j * prices[i - 1]] + j * weight[i - 1] is wrong 3. tip: j should begin from 1, because dp[k - (amounts[i - 1] + 1) * prices[i - 1]] is meaningless Optimize I class Solution { public int backpack ( int n , int [] prices , int [] weight , int [] amounts ) { int m = prices . length ; int [] dp = new int [ n + 1 ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 1 ; j = amounts [ i - 1 ]; j ++){ for ( int k = n ; k = prices [ i - 1 ]; k --) { dp [ k ] = Math . max ( dp [ k ], dp [ k - prices [ i - 1 ]] + weight [ i - 1 ]); } } } return dp [ n ]; } }","title":"Backpack IV"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#4-backpack-bounded-knapsack-problem-bkp","text":"","title":"4. Backpack bounded knapsack problem (BKP)"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#description","text":"Assume that you have n yuan. There are many kinds of rice in the supermarket. Each kind of rice is bagged and must be purchased in the whole bag. Given the weight, price and quantity of each type of rice, find the maximum weight of rice that you can purchase.","title":"Description"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#example-i","text":"Input: n = 8, prices = [3,2], weights = [300,160], amounts = [1,6] Output: 640 Explanation: Buy the second rice(price = 2) use all 8 money.","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#example-ii","text":"Input: n = 8, prices = [2,4], weight = [100,100], amounts = [4,2 ] Output: 400 Explanation: Buy the first rice(price = 2) use all 8 money.","title":"Example II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#question","text":"LintCode - 798. Backpack VII","title":"Question"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#transform-function","text":"dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k * prices[i - 1]] + k * weight[i - 1]);","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#template","text":"class Solution { public int backpack ( int n , int [] prices , int [] weight , int [] amounts ) { int m = prices . length ; int [][] dp = new int [ m + 1 ][ n + 1 ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 1 ; j = n ; j ++) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; for ( int k = 1 ; k = amounts [ i - 1 ] k * prices [ i - 1 ] = j ; k ++) { dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i - 1 ][ j - k * prices [ i - 1 ]] + k * weight [ i - 1 ]); } } } return dp [ m ][ n ]; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#another-template","text":"class Solution { public int backpack ( int n , int [] prices , int [] weight , int [] amounts ) { int m = prices . length ; int [][] dp = new int [ m + 1 ][ n + 1 ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = amounts [ i - 1 ]; j ++) { for ( int k = 1 ; k = n ; k ++) { if ( k = j * prices [ i - 1 ]) dp [ i ][ k ] = Math . max ( dp [ i ][ k ], dp [ i - 1 ][ k - j * prices [ i - 1 ]] + j * weight [ i - 1 ]); } } } return dp [ m ][ n ]; } }","title":"Another Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#optimize-analysis","text":"Wrong Answer: for (int i = 1; i = n; ++i) { for (int j = 1; j = amounts[i - 1]; ++j) { for (int k = n; k = j * prices[i - 1]; --k) { dp[k] = max(dp[k], dp[k - j * prices[i - 1]] + j * weight[i - 1]); } } } 1. dp[i - 1][k - j * prices[i - 1]] + j * weight[i - 1])\uff0c j = 0\u2026amounts[i-1] Max(dp[i][j], dp[i - 1][j]) 2. dp[k - prices[i - 1]] + weight[i - 1] (j = 1) is the max because k is from max to 1 so dp[k - j * prices[i - 1]] + j * weight[i - 1] is wrong 3. tip: j should begin from 1, because dp[k - (amounts[i - 1] + 1) * prices[i - 1]] is meaningless","title":"Optimize Analysis"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack04/#optimize-i","text":"class Solution { public int backpack ( int n , int [] prices , int [] weight , int [] amounts ) { int m = prices . length ; int [] dp = new int [ n + 1 ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 1 ; j = amounts [ i - 1 ]; j ++){ for ( int k = n ; k = prices [ i - 1 ]; k --) { dp [ k ] = Math . max ( dp [ k ], dp [ k - prices [ i - 1 ]] + weight [ i - 1 ]); } } } return dp [ n ]; } }","title":"Optimize I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/","text":"5. Backpack bounded knapsack problem (BKP) Description Given an integer array nums[] which contains n unique positive numbers, num[i] indicate the size of ith item. An integer target denotes the size of backpack. Find the number of ways to fill the backpack. Each item may be chosen unlimited number of times Example I Input: nums = [2,3,6,7] and target = 7 Output: 2 Explanation: Solution sets are: [7], [2, 2, 3] Example II Input: nums = [2,3,4,5] and target = 7 Output: 3 Explanation: Solution sets are: [2, 5], [3, 4], [2, 2, 3] Question LintCode - 562. Backpack IV Transform Function dp[i][j] += dp[i][j - 1]; dp[i][j] += dp[i - 1][j - k * nums[i - 1]]; Template class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [][] dp = new int [ n + 1 ][ target + 1 ]; for ( int i = 0 ; i = n ; i ++) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = target ; j ++) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; for ( int k = 1 ; k * nums [ i - 1 ] = j ; k ++) { dp [ i ][ j ] += dp [ i - 1 ][ j - k * nums [ i - 1 ]]; } } } return dp [ n ][ target ]; } } Optimize I class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [] dp = new int [ target + 1 ]; dp [ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = nums [ i - 1 ]; j = target ; j ++) { dp [ j ] += dp [ j - nums [ i - 1 ]]; } } return dp [ target ]; } }","title":"Backpack V"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#5-backpack-bounded-knapsack-problem-bkp","text":"","title":"5. Backpack bounded knapsack problem (BKP)"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#description","text":"Given an integer array nums[] which contains n unique positive numbers, num[i] indicate the size of ith item. An integer target denotes the size of backpack. Find the number of ways to fill the backpack. Each item may be chosen unlimited number of times","title":"Description"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#example-i","text":"Input: nums = [2,3,6,7] and target = 7 Output: 2 Explanation: Solution sets are: [7], [2, 2, 3]","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#example-ii","text":"Input: nums = [2,3,4,5] and target = 7 Output: 3 Explanation: Solution sets are: [2, 5], [3, 4], [2, 2, 3]","title":"Example II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#question","text":"LintCode - 562. Backpack IV","title":"Question"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#transform-function","text":"dp[i][j] += dp[i][j - 1]; dp[i][j] += dp[i - 1][j - k * nums[i - 1]];","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#template","text":"class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [][] dp = new int [ n + 1 ][ target + 1 ]; for ( int i = 0 ; i = n ; i ++) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = target ; j ++) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; for ( int k = 1 ; k * nums [ i - 1 ] = j ; k ++) { dp [ i ][ j ] += dp [ i - 1 ][ j - k * nums [ i - 1 ]]; } } } return dp [ n ][ target ]; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack05/#optimize-i","text":"class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [] dp = new int [ target + 1 ]; dp [ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = nums [ i - 1 ]; j = target ; j ++) { dp [ j ] += dp [ j - nums [ i - 1 ]]; } } return dp [ target ]; } }","title":"Optimize I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/","text":"6. Backpack bounded knapsack problem (BKP) Description Given n items with size nums[i] which an integer array and all positive numbers. An integer target denotes the size of a backpack. Find the number of possible fill the backpack. Each item may only be used once Example I Input: [1,2,3,3,7] and target 7, Output: A solution set is: [7],[1, 3, 3] Question LintCode - 563. Backpack V Transform Function dp[i][j] += dp[i][j - 1]; dp[i][j] += dp[i - 1][j - nums[i - 1]]; Template class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [][] dp = new int [ n + 1 ][ target + 1 ]; for ( int i = 0 ; i = n ; i ++) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = target ; j ++) { dp [ i ][ j ] += dp [ i - 1 ][ j ]; if ( j = nums [ i - 1 ]) dp [ i ][ j ] += dp [ i - 1 ][ j - nums [ i - 1 ]]; } } return dp [ n ][ target ]; } } Optimize I class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [] dp = new int [ target + 1 ]; dp [ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = target ; j = nums [ i - 1 ]; j --) { dp [ j ] += dp [ j - nums [ i - 1 ]]; } } return dp [ target ]; } }","title":"Backpack VI"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/#6-backpack-bounded-knapsack-problem-bkp","text":"","title":"6. Backpack bounded knapsack problem (BKP)"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/#description","text":"Given n items with size nums[i] which an integer array and all positive numbers. An integer target denotes the size of a backpack. Find the number of possible fill the backpack. Each item may only be used once","title":"Description"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/#example-i","text":"Input: [1,2,3,3,7] and target 7, Output: A solution set is: [7],[1, 3, 3]","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/#question","text":"LintCode - 563. Backpack V","title":"Question"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/#transform-function","text":"dp[i][j] += dp[i][j - 1]; dp[i][j] += dp[i - 1][j - nums[i - 1]];","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/#template","text":"class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [][] dp = new int [ n + 1 ][ target + 1 ]; for ( int i = 0 ; i = n ; i ++) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = target ; j ++) { dp [ i ][ j ] += dp [ i - 1 ][ j ]; if ( j = nums [ i - 1 ]) dp [ i ][ j ] += dp [ i - 1 ][ j - nums [ i - 1 ]]; } } return dp [ n ][ target ]; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack06/#optimize-i","text":"class Solution { public int backpack ( int [] nums , int target ) { int n = nums . length ; int [] dp = new int [ target + 1 ]; dp [ 0 ] = 1 ; for ( int i = 1 ; i = n ; i ++) { for ( int j = target ; j = nums [ i - 1 ]; j --) { dp [ j ] += dp [ j - nums [ i - 1 ]]; } } return dp [ target ]; } }","title":"Optimize I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/","text":"7. Backpack bounded knapsack problem (BKP) Description Give some coins of different value and their quantity. Find how many values which are in range 1 ~ n can these coins be combined Example I Input: n = 5 value = [1,4] amount = [2,1] Output: 4 Explanation: They can combine 4 numbers which are 1,2,4,5. Example II Input: n = 10 value = [1,2,4] amount = [2,1,1] Output: 8 Explanation: They can combine 8 numbers which are 1 ~ 8. Question LintCode - 799. Backpack VIII Transform Function dp[i][j] = dp[i - 1][j]; dp[i][j] |= dp[i - 1][j - k * value[i - 1]]; Template class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; boolean [][] dp = new boolean [ m + 1 ][ n + 1 ]; dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = n ; j ++) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; for ( int k = 1 ; k = amount [ i - 1 ] k * value [ i - 1 ] = j ; k ++) { dp [ i ][ j ] |= dp [ i - 1 ][ j - k * value [ i - 1 ]]; } } } int sum = 0 ; for ( int i = 1 ; i = n ; i ++) sum += dp [ m ][ i ] == true ? 1 : 0 ; return sum ; } } Optimize Analysis dp[i][j] : how many item i will be remained, when using items before i to get j; initialization: long[][] dp = new long[m + 1][n + 1]; Arrays.fill(dp[0],-1); dp[0][0] = 0; transform function: amount[i - 1] (dp[i - 1][j] = 0) dp[i][j] = -1 (j value[i - 1] || dp[i][j - value[i - 1]] = 0) dp[i + 1][j - value[i - 1] - 1 (other) Optimize I (Memory Limit Exceeded) class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; long [][] dp = new long [ m + 1 ][ n + 1 ]; Arrays . fill ( dp [ 0 ],- 1 ); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = n ; j ++) { if ( dp [ i - 1 ][ j ] = 0 ) { dp [ i ][ j ] = amount [ i - 1 ]; } else if ( j value [ i - 1 ] || dp [ i ][ j - value [ i - 1 ]] = 0 ) { dp [ i ][ j ] = - 1 ; } else { dp [ i ][ j ] = dp [ i ][ j - value [ i - 1 ]] - 1 ; } } } int sum = 0 ; for ( int i = 1 ; i = n ; ++ i ) { if ( dp [ m ][ i ] = 0 ) sum ++; } return sum ; } } Optimize II class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; long [] dp = new long [ n + 1 ]; Arrays . fill ( dp , - 1 ); dp [ 0 ] = 0 ; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = n ; j ++) { if ( dp [ j ] = 0 ) { dp [ j ] = amount [ i - 1 ]; } else if ( j value [ i - 1 ] || dp [ j - value [ i - 1 ]] = 0 ) { dp [ j ] = - 1 ; } else { dp [ j ] = dp [ j - value [ i - 1 ]] - 1 ; } } } int sum = 0 ; for ( int i = 1 ; i = n ; ++ i ) { if ( dp [ i ] = 0 ) sum ++; } return sum ; } } Optimize III class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; boolean [] dp = new boolean [ n + 1 ]; dp [ 0 ] = true ; int res = 0 ; for ( int i = 1 ; i = m ; i ++) { int [] cnt = new int [ n + 1 ]; for ( int j = value [ i - 1 ]; j = n ; j ++) { if (! dp [ j ] dp [ j - value [ i - 1 ]] cnt [ j - value [ i - 1 ]] amount [ i - 1 ]) { res ++; dp [ j ] = true ; cnt [ j ] = cnt [ j - value [ i - 1 ]] + 1 ; } } } return res ; } }","title":"Backpack VII"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#7-backpack-bounded-knapsack-problem-bkp","text":"","title":"7. Backpack bounded knapsack problem (BKP)"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#description","text":"Give some coins of different value and their quantity. Find how many values which are in range 1 ~ n can these coins be combined","title":"Description"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#example-i","text":"Input: n = 5 value = [1,4] amount = [2,1] Output: 4 Explanation: They can combine 4 numbers which are 1,2,4,5.","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#example-ii","text":"Input: n = 10 value = [1,2,4] amount = [2,1,1] Output: 8 Explanation: They can combine 8 numbers which are 1 ~ 8.","title":"Example II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#question","text":"LintCode - 799. Backpack VIII","title":"Question"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#transform-function","text":"dp[i][j] = dp[i - 1][j]; dp[i][j] |= dp[i - 1][j - k * value[i - 1]];","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#template","text":"class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; boolean [][] dp = new boolean [ m + 1 ][ n + 1 ]; dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = n ; j ++) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; for ( int k = 1 ; k = amount [ i - 1 ] k * value [ i - 1 ] = j ; k ++) { dp [ i ][ j ] |= dp [ i - 1 ][ j - k * value [ i - 1 ]]; } } } int sum = 0 ; for ( int i = 1 ; i = n ; i ++) sum += dp [ m ][ i ] == true ? 1 : 0 ; return sum ; } }","title":"Template"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#optimize-analysis","text":"dp[i][j] : how many item i will be remained, when using items before i to get j; initialization: long[][] dp = new long[m + 1][n + 1]; Arrays.fill(dp[0],-1); dp[0][0] = 0; transform function: amount[i - 1] (dp[i - 1][j] = 0) dp[i][j] = -1 (j value[i - 1] || dp[i][j - value[i - 1]] = 0) dp[i + 1][j - value[i - 1] - 1 (other)","title":"Optimize Analysis"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#optimize-i-memory-limit-exceeded","text":"class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; long [][] dp = new long [ m + 1 ][ n + 1 ]; Arrays . fill ( dp [ 0 ],- 1 ); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = n ; j ++) { if ( dp [ i - 1 ][ j ] = 0 ) { dp [ i ][ j ] = amount [ i - 1 ]; } else if ( j value [ i - 1 ] || dp [ i ][ j - value [ i - 1 ]] = 0 ) { dp [ i ][ j ] = - 1 ; } else { dp [ i ][ j ] = dp [ i ][ j - value [ i - 1 ]] - 1 ; } } } int sum = 0 ; for ( int i = 1 ; i = n ; ++ i ) { if ( dp [ m ][ i ] = 0 ) sum ++; } return sum ; } }","title":"Optimize I (Memory Limit Exceeded)"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#optimize-ii","text":"class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; long [] dp = new long [ n + 1 ]; Arrays . fill ( dp , - 1 ); dp [ 0 ] = 0 ; for ( int i = 1 ; i = m ; i ++) { for ( int j = 0 ; j = n ; j ++) { if ( dp [ j ] = 0 ) { dp [ j ] = amount [ i - 1 ]; } else if ( j value [ i - 1 ] || dp [ j - value [ i - 1 ]] = 0 ) { dp [ j ] = - 1 ; } else { dp [ j ] = dp [ j - value [ i - 1 ]] - 1 ; } } } int sum = 0 ; for ( int i = 1 ; i = n ; ++ i ) { if ( dp [ i ] = 0 ) sum ++; } return sum ; } }","title":"Optimize II"},{"location":"Algorithm/DynamicProgramming/Backpack/backpack07/#optimize-iii","text":"class Solution { public int backpack ( int n , int [] value , int [] amount ) { int m = value . length ; boolean [] dp = new boolean [ n + 1 ]; dp [ 0 ] = true ; int res = 0 ; for ( int i = 1 ; i = m ; i ++) { int [] cnt = new int [ n + 1 ]; for ( int j = value [ i - 1 ]; j = n ; j ++) { if (! dp [ j ] dp [ j - value [ i - 1 ]] cnt [ j - value [ i - 1 ]] amount [ i - 1 ]) { res ++; dp [ j ] = true ; cnt [ j ] = cnt [ j - value [ i - 1 ]] + 1 ; } } } return res ; } }","title":"Optimize III"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/","text":"1. Catalan number problem Description Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Question Link https://leetcode.com/problems/unique-binary-search-trees/description/ Example I Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST s: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 Questions LeetCode - 96. Unique Binary Search Trees Analysis Transform Function Solution I class Solution { public int numTrees ( int n ) { int [] dp = new int [ n + 1 ]; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i = n ; i ++) { for ( int j = 0 ; j i ; j ++) { dp [ i ] += dp [ j ] * dp [ i - j - 1 ]; } } return dp [ n ]; } } Solution II class Solution { public int numTrees ( int n ) { long res = 1 ; for ( int i = 0 ; i n ; i ++) { res = res * 2 * ( 2 * i + 1 ) / ( i + 2 ); } return ( int ) res ; } }","title":"Calatan Number I"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#1-catalan-number-problem","text":"","title":"1. Catalan number problem"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#description","text":"Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?","title":"Description"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#question-link","text":"https://leetcode.com/problems/unique-binary-search-trees/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#example-i","text":"Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST s: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3","title":"Example I"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#questions","text":"LeetCode - 96. Unique Binary Search Trees","title":"Questions"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#analysis","text":"","title":"Analysis"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#transform-function","text":"","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#solution-i","text":"class Solution { public int numTrees ( int n ) { int [] dp = new int [ n + 1 ]; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i = n ; i ++) { for ( int j = 0 ; j i ; j ++) { dp [ i ] += dp [ j ] * dp [ i - j - 1 ]; } } return dp [ n ]; } }","title":"Solution I"},{"location":"Algorithm/DynamicProgramming/Catalan/catalan01/#solution-ii","text":"class Solution { public int numTrees ( int n ) { long res = 1 ; for ( int i = 0 ; i n ; i ++) { res = res * 2 * ( 2 * i + 1 ) / ( i + 2 ); } return ( int ) res ; } }","title":"Solution II"},{"location":"Algorithm/DynamicProgramming/Interval/interval01/","text":"Interval I Description We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked. Question Link https://leetcode.com/problems/guess-number-higher-or-lower-ii/description/ Example I: n = 10, I pick 8. First round: You guess 5, I tell you that it's higher. You pay $5. Second round: You guess 7, I tell you that it's higher. You pay $7. Third round: You guess 9, I tell you that it's lower. You pay $9. Game over. 8 is the number I picked. You end up paying $5 + $7 + $9 = $21. Questions LeetCode - 375. Guess Number Higher or Lower II Transform Function for(int len = 1; len = n; len++) { for(int i = 1; i + len = n + 1; i++) { int global_min = Integer.MAX_VALUE; for(int k = i + 1; k j; k++) { int temp = k + Math.max(dp[i][k - 1], dp[k + 1][j]); global_min = Math.min(global_min, temp); } dp[i][j] = global_min; } } tips: len works from len = 3, because i ~ (k - 1) and (k + 1) ~ j needs at least 3 interval length Solution class Solution { public int getMoneyAmount ( int n ) { int [][] dp = new int [ n + 1 ][ n + 1 ]; for ( int len = 1 ; len = n ; len ++) { for ( int i = 1 ; i + len = n + 1 ; i ++) { int j = i + len - 1 ; if ( i == j ){ dp [ i ][ j ] = 0 ; continue ; } if ( i + 1 == j ) { dp [ i ][ j ] = i ; continue ; } int global_min = Integer . MAX_VALUE ; for ( int k = i + 1 ; k j ; k ++) { int temp = k + Math . max ( dp [ i ][ k - 1 ], dp [ k + 1 ][ j ]); global_min = Math . min ( global_min , temp ); } dp [ i ][ j ] = global_min ; } } return dp [ 1 ][ n ]; } }","title":"_**Interval I**_"},{"location":"Algorithm/DynamicProgramming/Interval/interval01/#interval-i","text":"","title":"Interval I"},{"location":"Algorithm/DynamicProgramming/Interval/interval01/#description","text":"We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked.","title":"Description"},{"location":"Algorithm/DynamicProgramming/Interval/interval01/#question-link","text":"https://leetcode.com/problems/guess-number-higher-or-lower-ii/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/Interval/interval01/#example-i","text":"n = 10, I pick 8. First round: You guess 5, I tell you that it's higher. You pay $5. Second round: You guess 7, I tell you that it's higher. You pay $7. Third round: You guess 9, I tell you that it's lower. You pay $9. Game over. 8 is the number I picked. You end up paying $5 + $7 + $9 = $21.","title":"Example I:"},{"location":"Algorithm/DynamicProgramming/Interval/interval01/#questions","text":"LeetCode - 375. Guess Number Higher or Lower II","title":"Questions"},{"location":"Algorithm/DynamicProgramming/Interval/interval01/#transform-function","text":"for(int len = 1; len = n; len++) { for(int i = 1; i + len = n + 1; i++) { int global_min = Integer.MAX_VALUE; for(int k = i + 1; k j; k++) { int temp = k + Math.max(dp[i][k - 1], dp[k + 1][j]); global_min = Math.min(global_min, temp); } dp[i][j] = global_min; } } tips: len works from len = 3, because i ~ (k - 1) and (k + 1) ~ j needs at least 3 interval length","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Interval/interval01/#solution","text":"class Solution { public int getMoneyAmount ( int n ) { int [][] dp = new int [ n + 1 ][ n + 1 ]; for ( int len = 1 ; len = n ; len ++) { for ( int i = 1 ; i + len = n + 1 ; i ++) { int j = i + len - 1 ; if ( i == j ){ dp [ i ][ j ] = 0 ; continue ; } if ( i + 1 == j ) { dp [ i ][ j ] = i ; continue ; } int global_min = Integer . MAX_VALUE ; for ( int k = i + 1 ; k j ; k ++) { int temp = k + Math . max ( dp [ i ][ k - 1 ], dp [ k + 1 ][ j ]); global_min = Math . min ( global_min , temp ); } dp [ i ][ j ] = global_min ; } } return dp [ 1 ][ n ]; } }","title":"Solution"},{"location":"Algorithm/DynamicProgramming/Interval/interval02/","text":"Interval II Description Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note: You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. 0 \u2264 n \u2264 500, 0 \u2264 nums[i] \u2264 100 Question Link https://leetcode.com/problems/maximum-product-subarray/description/ Example I: Input: [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] -- [3,5,8] -- [3,8] -- [8] -- [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 Questions LeetCode - 312. Burst Balloons Transform Function for(int len = 1; len = n; len++) { for(int i = 1; i + len - 1 = n; i++) { int j = i + len - 1; for(int k = i; k = j; k++) { dp[i][j] = Math.max(dp[i][j], nums[i - 1] * nums[k] * nums[j + 1] + dp[i][k - 1] + dp[k + 1][j]); } } } Solution class Solution { public int maxCoins ( int [] inums ) { int [] nums = new int [ inums . length + 2 ]; int n = 1 ; for ( int num : inums ) nums [ n ++] = num ; nums [ 0 ] = nums [ n ++] = 1 ; int [][] dp = new int [ n ][ n ]; n = inums . length ; for ( int len = 1 ; len = n ; len ++) { for ( int i = 1 ; i + len - 1 = n ; i ++) { int j = i + len - 1 ; for ( int k = i ; k = j ; k ++) { dp [ i ][ j ] = Math . max ( dp [ i ][ j ], nums [ i - 1 ] * nums [ k ] * nums [ j + 1 ] + dp [ i ][ k - 1 ] + dp [ k + 1 ][ j ]); } } } return dp [ 1 ][ n ]; } }","title":"_**Interval II**_"},{"location":"Algorithm/DynamicProgramming/Interval/interval02/#interval-ii","text":"","title":"Interval II"},{"location":"Algorithm/DynamicProgramming/Interval/interval02/#description","text":"Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note: You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. 0 \u2264 n \u2264 500, 0 \u2264 nums[i] \u2264 100","title":"Description"},{"location":"Algorithm/DynamicProgramming/Interval/interval02/#question-link","text":"https://leetcode.com/problems/maximum-product-subarray/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/Interval/interval02/#example-i","text":"Input: [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] -- [3,5,8] -- [3,8] -- [8] -- [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167","title":"Example I:"},{"location":"Algorithm/DynamicProgramming/Interval/interval02/#questions","text":"LeetCode - 312. Burst Balloons","title":"Questions"},{"location":"Algorithm/DynamicProgramming/Interval/interval02/#transform-function","text":"for(int len = 1; len = n; len++) { for(int i = 1; i + len - 1 = n; i++) { int j = i + len - 1; for(int k = i; k = j; k++) { dp[i][j] = Math.max(dp[i][j], nums[i - 1] * nums[k] * nums[j + 1] + dp[i][k - 1] + dp[k + 1][j]); } } }","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/Interval/interval02/#solution","text":"class Solution { public int maxCoins ( int [] inums ) { int [] nums = new int [ inums . length + 2 ]; int n = 1 ; for ( int num : inums ) nums [ n ++] = num ; nums [ 0 ] = nums [ n ++] = 1 ; int [][] dp = new int [ n ][ n ]; n = inums . length ; for ( int len = 1 ; len = n ; len ++) { for ( int i = 1 ; i + len - 1 = n ; i ++) { int j = i + len - 1 ; for ( int k = i ; k = j ; k ++) { dp [ i ][ j ] = Math . max ( dp [ i ][ j ], nums [ i - 1 ] * nums [ k ] * nums [ j + 1 ] + dp [ i ][ k - 1 ] + dp [ k + 1 ][ j ]); } } } return dp [ 1 ][ n ]; } }","title":"Solution"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/","text":"Multiple States I Description Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Question Link https://leetcode.com/problems/maximum-product-subarray/description/ Example I: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example II: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Questions LeetCode - 152. Maximum Product Subarray Transform Function f(k) = Largest product subarray, from index 0 up to k. g(k) = Smallest product subarray, from index 0 up to k. f(k) = max( f(k-1) A[k], A[k], g(k-1) A[k] ) g(k) = min( g(k-1) A[k], A[k], f(k-1) A[k] ) Solution class Solution { public int maxProduct ( int [] nums ) { assert nums . length 0 ; int max = nums [ 0 ], min = nums [ 0 ], res = nums [ 0 ]; for ( int i = 1 ; i nums . length ; i ++) { int mx = max , mn = min ; max = Math . max ( Math . max ( nums [ i ], mx * nums [ i ]), mn * nums [ i ]); min = Math . min ( Math . min ( nums [ i ], mx * nums [ i ]), mn * nums [ i ]); res = Math . max ( res , max ); } return res ; } }","title":"Maximum Product Subarray"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#multiple-states-i","text":"","title":"Multiple States I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#description","text":"Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.","title":"Description"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#question-link","text":"https://leetcode.com/problems/maximum-product-subarray/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#example-i","text":"Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.","title":"Example I:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#example-ii","text":"Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.","title":"Example II:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#questions","text":"LeetCode - 152. Maximum Product Subarray","title":"Questions"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#transform-function","text":"f(k) = Largest product subarray, from index 0 up to k. g(k) = Smallest product subarray, from index 0 up to k. f(k) = max( f(k-1) A[k], A[k], g(k-1) A[k] ) g(k) = min( g(k-1) A[k], A[k], f(k-1) A[k] )","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states01/#solution","text":"class Solution { public int maxProduct ( int [] nums ) { assert nums . length 0 ; int max = nums [ 0 ], min = nums [ 0 ], res = nums [ 0 ]; for ( int i = 1 ; i nums . length ; i ++) { int mx = max , mn = min ; max = Math . max ( Math . max ( nums [ i ], mx * nums [ i ]), mn * nums [ i ]); min = Math . min ( Math . min ( nums [ i ], mx * nums [ i ]), mn * nums [ i ]); res = Math . max ( res , max ); } return res ; } }","title":"Solution"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/","text":"Multiple States II Description You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Question Link https://leetcode.com/problems/house-robber/description/ Example I: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example II: Input: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. Questions LeetCode - 198. House Robber Transform Function rob[i] = notrob[i - 1] + house[i] notrob = Math.max(rob[i - 1], notrob[i - 1]) return Math.max(rob[n], notrob[n]) Solution I class Solution { public int rob ( int [] nums ) { if ( nums == null || nums . length == 0 ) return 0 ; int n = nums . length ; int [][] dp = new int [ n ][ 2 ]; dp [ 0 ][ 0 ] = nums [ 0 ]; for ( int i = 1 ; i n ; i ++) { dp [ i ][ 0 ] = dp [ i - 1 ][ 1 ] + nums [ i ]; dp [ i ][ 1 ] = Math . max ( dp [ i - 1 ][ 0 ], dp [ i - 1 ][ 1 ]); } return Math . max ( dp [ n - 1 ][ 0 ], dp [ n - 1 ][ 1 ]); } } Solution II class Solution { public int rob ( int [] nums ) { if ( nums == null || nums . length == 0 ) return 0 ; int rob = 0 ; int notrob = 0 ; for ( int num : nums ) { int prev_rob = rob ; rob = notrob + num ; notrob = Math . max ( prev_rob , notrob ); } return Math . max ( rob , notrob ); } }","title":"House Robber I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#multiple-states-ii","text":"","title":"Multiple States II"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#description","text":"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.","title":"Description"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#question-link","text":"https://leetcode.com/problems/house-robber/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#example-i","text":"Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.","title":"Example I:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#example-ii","text":"Input: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.","title":"Example II:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#questions","text":"LeetCode - 198. House Robber","title":"Questions"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#transform-function","text":"rob[i] = notrob[i - 1] + house[i] notrob = Math.max(rob[i - 1], notrob[i - 1]) return Math.max(rob[n], notrob[n])","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#solution-i","text":"class Solution { public int rob ( int [] nums ) { if ( nums == null || nums . length == 0 ) return 0 ; int n = nums . length ; int [][] dp = new int [ n ][ 2 ]; dp [ 0 ][ 0 ] = nums [ 0 ]; for ( int i = 1 ; i n ; i ++) { dp [ i ][ 0 ] = dp [ i - 1 ][ 1 ] + nums [ i ]; dp [ i ][ 1 ] = Math . max ( dp [ i - 1 ][ 0 ], dp [ i - 1 ][ 1 ]); } return Math . max ( dp [ n - 1 ][ 0 ], dp [ n - 1 ][ 1 ]); } }","title":"Solution I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states02/#solution-ii","text":"class Solution { public int rob ( int [] nums ) { if ( nums == null || nums . length == 0 ) return 0 ; int rob = 0 ; int notrob = 0 ; for ( int num : nums ) { int prev_rob = rob ; rob = notrob + num ; notrob = Math . max ( prev_rob , notrob ); } return Math . max ( rob , notrob ); } }","title":"Solution II"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/","text":"Multiple States III Description You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Question Link https://leetcode.com/problems/house-robber-ii/description/ Example I: Input: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. Example II: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Questions LeetCode - 213. House Robber II Transform Function rob[i] = notrob[i - 1] + house[i] notrob = Math.max(rob[i - 1], notrob[i - 1]) return Math.max(rob[n], notrob[n]) Solution I class Solution { public int rob ( int [] nums ) { int n = nums . length ; if ( n == 0 ) return 0 ; if ( n == 1 ) return nums [ 0 ]; if ( n == 2 ) return nums [ 0 ] nums [ 1 ] ? nums [ 0 ] : nums [ 1 ]; return Math . max ( helper ( nums , 0 , n - 2 ), helper ( nums , 1 , n - 1 )); } int helper ( int [] nums , int l , int r ) { int [][] dp = new int [ 2 ][ nums . length ]; dp [ 0 ][ l ] = nums [ l ]; for ( int i = l + 1 ; i nums . length ; i ++) { dp [ 0 ][ i ] = dp [ 1 ][ i - 1 ] + nums [ i ]; dp [ 1 ][ i ] = Math . max ( dp [ 1 ][ i - 1 ], dp [ 0 ][ i - 1 ]); } return Math . max ( dp [ 1 ][ r ], dp [ 0 ][ r ]); } }","title":"House Robber II"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#multiple-states-iii","text":"","title":"Multiple States III"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#description","text":"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.","title":"Description"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#question-link","text":"https://leetcode.com/problems/house-robber-ii/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#example-i","text":"Input: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.","title":"Example I:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#example-ii","text":"Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.","title":"Example II:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#questions","text":"LeetCode - 213. House Robber II","title":"Questions"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#transform-function","text":"rob[i] = notrob[i - 1] + house[i] notrob = Math.max(rob[i - 1], notrob[i - 1]) return Math.max(rob[n], notrob[n])","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states03/#solution-i","text":"class Solution { public int rob ( int [] nums ) { int n = nums . length ; if ( n == 0 ) return 0 ; if ( n == 1 ) return nums [ 0 ]; if ( n == 2 ) return nums [ 0 ] nums [ 1 ] ? nums [ 0 ] : nums [ 1 ]; return Math . max ( helper ( nums , 0 , n - 2 ), helper ( nums , 1 , n - 1 )); } int helper ( int [] nums , int l , int r ) { int [][] dp = new int [ 2 ][ nums . length ]; dp [ 0 ][ l ] = nums [ l ]; for ( int i = l + 1 ; i nums . length ; i ++) { dp [ 0 ][ i ] = dp [ 1 ][ i - 1 ] + nums [ i ]; dp [ 1 ][ i ] = Math . max ( dp [ 1 ][ i - 1 ], dp [ 0 ][ i - 1 ]); } return Math . max ( dp [ 1 ][ r ], dp [ 0 ][ r ]); } }","title":"Solution I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/","text":"Multiple States IV Description The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Question Link https://leetcode.com/problems/house-robber-iii/description/ Example I: Input: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1 Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example II: Input: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. Questions LeetCode - 337. House Robber III Transform Function int[]{rob, notrob] = new int[]{left.notrob + right.notrob + cur.val, Math.max(left.notrob, left.rob) + Math.(right.notrob, right.rob) Solution I class Solution { public int rob ( TreeNode root ) { int [] res = helper ( root ); return Math . max ( res [ 0 ], res [ 1 ]); } int [] helper ( TreeNode root ) { if ( root == null ) return new int []{ 0 , 0 }; int [] left = helper ( root . left ); int [] right = helper ( root . right ); int rob = left [ 1 ] + right [ 1 ] + root . val ; int notrob = Math . max ( left [ 0 ], left [ 1 ]) + Math . max ( right [ 0 ], right [ 1 ]); return new int []{ rob , notrob }; } }","title":"House Robber III"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#multiple-states-iv","text":"","title":"Multiple States IV"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#description","text":"The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police.","title":"Description"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#question-link","text":"https://leetcode.com/problems/house-robber-iii/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#example-i","text":"Input: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1 Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.","title":"Example I:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#example-ii","text":"Input: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.","title":"Example II:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#questions","text":"LeetCode - 337. House Robber III","title":"Questions"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#transform-function","text":"int[]{rob, notrob] = new int[]{left.notrob + right.notrob + cur.val, Math.max(left.notrob, left.rob) + Math.(right.notrob, right.rob)","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states04/#solution-i","text":"class Solution { public int rob ( TreeNode root ) { int [] res = helper ( root ); return Math . max ( res [ 0 ], res [ 1 ]); } int [] helper ( TreeNode root ) { if ( root == null ) return new int []{ 0 , 0 }; int [] left = helper ( root . left ); int [] right = helper ( root . right ); int rob = left [ 1 ] + right [ 1 ] + root . val ; int notrob = Math . max ( left [ 0 ], left [ 1 ]) + Math . max ( right [ 0 ], right [ 1 ]); return new int []{ rob , notrob }; } }","title":"Solution I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states05/","text":"Multiple States V Description Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Question Link https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/ Example I Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example II: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. Questions LeetCode - 121. Best Time to Buy and Sell Stock Transform Function dp[i] = prices[i] - min_prices Template I class Solution { public int maxProfit ( int [] prices ) { int n = prices . length ; int [] dp = new int [ n + 1 ]; dp [ 0 ] = Integer . MAX_VALUE ; int min = Integer . MAX_VALUE , res = 0 ; for ( int i = 1 ; i = n ; i ++) { min = Math . min ( min , prices [ i - 1 ]); dp [ i ] = min ; res = Math . max ( res , prices [ i - 1 ] - dp [ i - 1 ]); } return res ; } } Optimized min = min_price_before res = Math.max(prices[i] - min) Template II class Solution { public int maxProfit ( int [] prices ) { int min = Integer . MAX_VALUE , res = 0 ; for ( int p : prices ) { min = Math . min ( p , min ); res = Math . max ( p - min , res ); } return res ; } }","title":"Best Time to Buy and Sell Stock I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states05/#multiple-states-v","text":"","title":"Multiple States V"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states05/#description","text":"Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one.","title":"Description"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states05/#question-link","text":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states05/#example-i","text":"Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price.","title":"Example I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states05/#example-ii","text":"Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.","title":"Example II:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states05/#questions","text":"LeetCode - 121. Best Time to Buy and Sell Stock","title":"Questions"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states05/#transform-function","text":"dp[i] = prices[i] - min_prices","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states05/#template-i","text":"class Solution { public int maxProfit ( int [] prices ) { int n = prices . length ; int [] dp = new int [ n + 1 ]; dp [ 0 ] = Integer . MAX_VALUE ; int min = Integer . MAX_VALUE , res = 0 ; for ( int i = 1 ; i = n ; i ++) { min = Math . min ( min , prices [ i - 1 ]); dp [ i ] = min ; res = Math . max ( res , prices [ i - 1 ] - dp [ i - 1 ]); } return res ; } }","title":"Template I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states05/#optimized","text":"min = min_price_before res = Math.max(prices[i] - min)","title":"Optimized"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states05/#template-ii","text":"class Solution { public int maxProfit ( int [] prices ) { int min = Integer . MAX_VALUE , res = 0 ; for ( int p : prices ) { min = Math . min ( p , min ); res = Math . max ( p - min , res ); } return res ; } }","title":"Template II"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states06/","text":"Multiple States VI Description Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Question Link https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/ Example I: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example II: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example III: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. Questions LeetCode - 123. Best Time to Buy and Sell Stock III Transform Function before[i] = Math.max(before[i - 1], prices[i] - min); after[i] = Math.max(after[i + 1], max - prices[i]); res = Math.max(before[i] + after[i], res); Template I class Solution { public int maxProfit ( int [] prices ) { if ( prices == null || prices . length = 1 ) return 0 ; int n = prices . length ; int [] before = new int [ n ]; int min = prices [ 0 ]; for ( int i = 1 ; i n ; i ++) { min = Math . min ( min , prices [ i ]); before [ i ] = Math . max ( before [ i - 1 ], prices [ i ] - min ); } int [] after = new int [ n ]; int max = prices [ n - 1 ]; for ( int i = n - 2 ; i = 0 ; i --) { max = Math . max ( prices [ i ], max ); after [ i ] = Math . max ( after [ i + 1 ], max - prices [ i ]); } int res = 0 ; for ( int i = 0 ; i n ; i ++) res = Math . max ( before [ i ] + after [ i ], res ); return res ; } } Optimized hold_one[i] = Math.max(-prices[i], hold_one[i - 1]) hold_one_sell_one = Math.max(hold_one[i - 1] + prices[i], hold_one_sell_one[i - 1]) hold_two_sell_one = Math.max(hold_one_sell_one[i - 1] - prices[i], hold_two_sell_one[i - 1]) hold_two_sell_two = Math.max(hold_two_sell_one[i - 1] + prices[i], hold_two_sell_two[i - 1]) Template II class Solution { public int maxProfit ( int [] prices ) { if ( prices == null || prices . length == 0 ) return 0 ; int n = prices . length ; int [] holdOne = new int [ n + 1 ]; int [] holdOneSellOne = new int [ n + 1 ]; int [] holdTwoSellOne = new int [ n + 1 ]; int [] holdTwoSellTwo = new int [ n + 1 ]; holdOne [ 0 ] = Integer . MIN_VALUE ; holdTwoSellOne [ 0 ] = Integer . MIN_VALUE ; for ( int i = 1 ; i = n ; i ++) { holdOne [ i ] = Math . max ( holdOne [ i - 1 ], - prices [ i - 1 ]); holdOneSellOne [ i ] = Math . max ( holdOneSellOne [ i - 1 ], holdOne [ i - 1 ] + prices [ i - 1 ]); holdTwoSellOne [ i ] = Math . max ( holdTwoSellOne [ i - 1 ], holdOneSellOne [ i - 1 ] - prices [ i - 1 ]); holdTwoSellTwo [ i ] = Math . max ( holdTwoSellTwo [ i - 1 ], holdTwoSellOne [ i - 1 ] + prices [ i - 1 ]); } return holdTwoSellTwo [ n ]; } } Optimized int hold_one = Integer.MIN_VALUE; int hold_one_sell_one = 0; int hold_two_sell_one = Integer.MIN_VALUE; int hold_two_sell_two = 0; Template III class Solution { public int maxProfit ( int [] prices ) { int hold_one = Integer . MIN_VALUE , hold_one_sell_one = 0 ; int hold_two_sell_one = Integer . MIN_VALUE ; int hold_two_sell_two = 0 ; for ( int p : prices ) { hold_one = Math . max ( hold_one , - p ); hold_one_sell_one = Math . max ( hold_one + p , hold_one_sell_one ); hold_two_sell_one = Math . max ( hold_one_sell_one - p , hold_two_sell_one ); hold_two_sell_two = Math . max ( hold_two_sell_one + p , hold_two_sell_two ); } return hold_two_sell_two ; } }","title":"Best Time to Buy and Sell Stock III"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states06/#multiple-states-vi","text":"","title":"Multiple States VI"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states06/#description","text":"Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).","title":"Description"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states06/#question-link","text":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states06/#example-i","text":"Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.","title":"Example I:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states06/#example-ii","text":"Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.","title":"Example II:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states06/#example-iii","text":"Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.","title":"Example III:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states06/#questions","text":"LeetCode - 123. Best Time to Buy and Sell Stock III","title":"Questions"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states06/#transform-function","text":"before[i] = Math.max(before[i - 1], prices[i] - min); after[i] = Math.max(after[i + 1], max - prices[i]); res = Math.max(before[i] + after[i], res);","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states06/#template-i","text":"class Solution { public int maxProfit ( int [] prices ) { if ( prices == null || prices . length = 1 ) return 0 ; int n = prices . length ; int [] before = new int [ n ]; int min = prices [ 0 ]; for ( int i = 1 ; i n ; i ++) { min = Math . min ( min , prices [ i ]); before [ i ] = Math . max ( before [ i - 1 ], prices [ i ] - min ); } int [] after = new int [ n ]; int max = prices [ n - 1 ]; for ( int i = n - 2 ; i = 0 ; i --) { max = Math . max ( prices [ i ], max ); after [ i ] = Math . max ( after [ i + 1 ], max - prices [ i ]); } int res = 0 ; for ( int i = 0 ; i n ; i ++) res = Math . max ( before [ i ] + after [ i ], res ); return res ; } }","title":"Template I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states06/#optimized","text":"hold_one[i] = Math.max(-prices[i], hold_one[i - 1]) hold_one_sell_one = Math.max(hold_one[i - 1] + prices[i], hold_one_sell_one[i - 1]) hold_two_sell_one = Math.max(hold_one_sell_one[i - 1] - prices[i], hold_two_sell_one[i - 1]) hold_two_sell_two = Math.max(hold_two_sell_one[i - 1] + prices[i], hold_two_sell_two[i - 1])","title":"Optimized"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states06/#template-ii","text":"class Solution { public int maxProfit ( int [] prices ) { if ( prices == null || prices . length == 0 ) return 0 ; int n = prices . length ; int [] holdOne = new int [ n + 1 ]; int [] holdOneSellOne = new int [ n + 1 ]; int [] holdTwoSellOne = new int [ n + 1 ]; int [] holdTwoSellTwo = new int [ n + 1 ]; holdOne [ 0 ] = Integer . MIN_VALUE ; holdTwoSellOne [ 0 ] = Integer . MIN_VALUE ; for ( int i = 1 ; i = n ; i ++) { holdOne [ i ] = Math . max ( holdOne [ i - 1 ], - prices [ i - 1 ]); holdOneSellOne [ i ] = Math . max ( holdOneSellOne [ i - 1 ], holdOne [ i - 1 ] + prices [ i - 1 ]); holdTwoSellOne [ i ] = Math . max ( holdTwoSellOne [ i - 1 ], holdOneSellOne [ i - 1 ] - prices [ i - 1 ]); holdTwoSellTwo [ i ] = Math . max ( holdTwoSellTwo [ i - 1 ], holdTwoSellOne [ i - 1 ] + prices [ i - 1 ]); } return holdTwoSellTwo [ n ]; } }","title":"Template II"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states06/#optimized_1","text":"int hold_one = Integer.MIN_VALUE; int hold_one_sell_one = 0; int hold_two_sell_one = Integer.MIN_VALUE; int hold_two_sell_two = 0;","title":"Optimized"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states06/#template-iii","text":"class Solution { public int maxProfit ( int [] prices ) { int hold_one = Integer . MIN_VALUE , hold_one_sell_one = 0 ; int hold_two_sell_one = Integer . MIN_VALUE ; int hold_two_sell_two = 0 ; for ( int p : prices ) { hold_one = Math . max ( hold_one , - p ); hold_one_sell_one = Math . max ( hold_one + p , hold_one_sell_one ); hold_two_sell_one = Math . max ( hold_one_sell_one - p , hold_two_sell_one ); hold_two_sell_two = Math . max ( hold_two_sell_one + p , hold_two_sell_two ); } return hold_two_sell_two ; } }","title":"Template III"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states07/","text":"Multiple States VII Description Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Question Link https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/ Example I Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example II: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Questions LeetCode - 188. Best Time to Buy and Sell Stock IV Transform Function / | dp[i][j - 1] dp[i][j] = max | | prices[j] - prices[m] + dp[i - 1][m] \\ Template I // Submission Result: Memory Limit Exceeded class Solution { public int maxProfit ( int k , int [] prices ) { if ( k == 0 || prices . length == 0 ) return 0 ; int m = k , n = prices . length ; int [][] dp = new int [ m + 1 ][ n ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 1 ; j n ; j ++) { for ( int s = 0 ; s j ; s ++) { dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i - 1 ][ s ] + prices [ j ] - prices [ s ]); } dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i ][ j - 1 ]); } } return dp [ m ][ n - 1 ]; } } Optimized i = 1, j = 3 dp[1][0] - prices[0] + prices[3] dp[1][1] - prices[1] + prices[3] dp[1][2] - prices[2] + prices[3] Template II class Solution { public int maxProfit ( int k , int [] prices ) { if ( k == 0 || prices . length == 0 ) return 0 ; if ( k = prices . length / 2 ) return helper ( prices ); int n = prices . length ; int [] dp = new int [ n ]; int [] prev = new int [ n ]; for ( int i = 1 ; i = k ; i ++) { int maxDiff = - prices [ 0 ]; for ( int j = 1 ; j n ; j ++) { dp [ j ] = Math . max ( dp [ j - 1 ], maxDiff + prices [ j ]); maxDiff = Math . max ( maxDiff , prev [ j ] - prices [ j ]); } prev = Arrays . copyOf ( dp , dp . length ); } return dp [ n - 1 ]; } int helper ( int [] prices ) { int res = 0 ; for ( int i = 1 ; i prices . length ; i ++) { if ( prices [ i ] prices [ i - 1 ]) res += prices [ i ] - prices [ i - 1 ]; } return res ; } } Optimized transaction on i th day dp[i] = max{dp[i - 1][no tansaction] + sell, dp[i - 1][do transaction] + buy} for (int i = 0; i n; i++) { dp[i][no transaction] = max(dp[i - 1][do transaction] + buy, dp[i - 1][no tansaction] + hold ); dp[i][do transaction] = max(dp[i - 1][no transaction] + sell, dp[i - 1][do transaction] + hold ); } return dp[n - 1][do transaction]; for (int i = 0; i n; i++) { for (int j = 0; j = k; j++) { dp[i][no transaction][j] = max {dp[i - 1][do transaction][j - 1] + buy, dp[i - 1][no transaction][j] + hold }; dp[i][do transaction][j] = max {dp[i - 1][no transaction][j] + sell, dp[i - 1][do transaction][j] + hold }; } } return dp[n-1][do transaction]; hold[i][j] = max {sold[i - 1][j - 1] + buy, hold[i - 1][j]} sold[i][j] = max {hold[i - 1][j] + sell, sold[i - 1][j]} Template III class Solution { public int maxProfit ( int k , int [] prices ) { if ( k == 0 || prices . length == 0 ) return 0 ; if ( k = prices . length / 2 ) return helper ( prices ); int n = prices . length ; int [][] hold = new int [ n ][ k + 1 ]; int [][] sold = new int [ n ][ k + 1 ]; for ( int i = 1 ; i n ; i ++) { int diff = prices [ i ] - prices [ i - 1 ]; for ( int j = 1 ; j = k ; j ++) { hold [ i ][ j ] = Math . max ( sold [ i - 1 ][ j - 1 ] + diff , hold [ i - 1 ][ j ] + diff ); sold [ i ][ j ] = Math . max ( hold [ i ][ j ], sold [ i - 1 ][ j ]); } } return sold [ n - 1 ][ k ]; } int helper ( int [] prices ) { int res = 0 ; for ( int i = 1 ; i prices . length ; i ++) { if ( prices [ i ] prices [ i - 1 ]) res += prices [ i ] - prices [ i - 1 ]; } return res ; } }","title":"Best Time to Buy and Sell Stock IV"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states07/#multiple-states-vii","text":"","title":"Multiple States VII"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states07/#description","text":"Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions.","title":"Description"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states07/#question-link","text":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states07/#example-i","text":"Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.","title":"Example I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states07/#example-ii","text":"Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.","title":"Example II:"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states07/#questions","text":"LeetCode - 188. Best Time to Buy and Sell Stock IV","title":"Questions"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states07/#transform-function","text":"/ | dp[i][j - 1] dp[i][j] = max | | prices[j] - prices[m] + dp[i - 1][m] \\","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states07/#template-i","text":"// Submission Result: Memory Limit Exceeded class Solution { public int maxProfit ( int k , int [] prices ) { if ( k == 0 || prices . length == 0 ) return 0 ; int m = k , n = prices . length ; int [][] dp = new int [ m + 1 ][ n ]; for ( int i = 1 ; i = m ; i ++) { for ( int j = 1 ; j n ; j ++) { for ( int s = 0 ; s j ; s ++) { dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i - 1 ][ s ] + prices [ j ] - prices [ s ]); } dp [ i ][ j ] = Math . max ( dp [ i ][ j ], dp [ i ][ j - 1 ]); } } return dp [ m ][ n - 1 ]; } }","title":"Template I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states07/#optimized","text":"i = 1, j = 3 dp[1][0] - prices[0] + prices[3] dp[1][1] - prices[1] + prices[3] dp[1][2] - prices[2] + prices[3]","title":"Optimized"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states07/#template-ii","text":"class Solution { public int maxProfit ( int k , int [] prices ) { if ( k == 0 || prices . length == 0 ) return 0 ; if ( k = prices . length / 2 ) return helper ( prices ); int n = prices . length ; int [] dp = new int [ n ]; int [] prev = new int [ n ]; for ( int i = 1 ; i = k ; i ++) { int maxDiff = - prices [ 0 ]; for ( int j = 1 ; j n ; j ++) { dp [ j ] = Math . max ( dp [ j - 1 ], maxDiff + prices [ j ]); maxDiff = Math . max ( maxDiff , prev [ j ] - prices [ j ]); } prev = Arrays . copyOf ( dp , dp . length ); } return dp [ n - 1 ]; } int helper ( int [] prices ) { int res = 0 ; for ( int i = 1 ; i prices . length ; i ++) { if ( prices [ i ] prices [ i - 1 ]) res += prices [ i ] - prices [ i - 1 ]; } return res ; } }","title":"Template II"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states07/#optimized_1","text":"transaction on i th day dp[i] = max{dp[i - 1][no tansaction] + sell, dp[i - 1][do transaction] + buy} for (int i = 0; i n; i++) { dp[i][no transaction] = max(dp[i - 1][do transaction] + buy, dp[i - 1][no tansaction] + hold ); dp[i][do transaction] = max(dp[i - 1][no transaction] + sell, dp[i - 1][do transaction] + hold ); } return dp[n - 1][do transaction]; for (int i = 0; i n; i++) { for (int j = 0; j = k; j++) { dp[i][no transaction][j] = max {dp[i - 1][do transaction][j - 1] + buy, dp[i - 1][no transaction][j] + hold }; dp[i][do transaction][j] = max {dp[i - 1][no transaction][j] + sell, dp[i - 1][do transaction][j] + hold }; } } return dp[n-1][do transaction]; hold[i][j] = max {sold[i - 1][j - 1] + buy, hold[i - 1][j]} sold[i][j] = max {hold[i - 1][j] + sell, sold[i - 1][j]}","title":"Optimized"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states07/#template-iii","text":"class Solution { public int maxProfit ( int k , int [] prices ) { if ( k == 0 || prices . length == 0 ) return 0 ; if ( k = prices . length / 2 ) return helper ( prices ); int n = prices . length ; int [][] hold = new int [ n ][ k + 1 ]; int [][] sold = new int [ n ][ k + 1 ]; for ( int i = 1 ; i n ; i ++) { int diff = prices [ i ] - prices [ i - 1 ]; for ( int j = 1 ; j = k ; j ++) { hold [ i ][ j ] = Math . max ( sold [ i - 1 ][ j - 1 ] + diff , hold [ i - 1 ][ j ] + diff ); sold [ i ][ j ] = Math . max ( hold [ i ][ j ], sold [ i - 1 ][ j ]); } } return sold [ n - 1 ][ k ]; } int helper ( int [] prices ) { int res = 0 ; for ( int i = 1 ; i prices . length ; i ++) { if ( prices [ i ] prices [ i - 1 ]) res += prices [ i ] - prices [ i - 1 ]; } return res ; } }","title":"Template III"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states08/","text":"Multiple States VIII Description There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses. Note: All costs are positive integers. Question Link https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/ Example I Input: [[17,2,17],[16,16,5],[14,3,19]] Output: 10 Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue. Minimum cost: 2 + 5 + 3 = 10. Questions LeetCode - 256. Paint House Transform Function dp[0][i] = costs[i][0] + Math.min(dp[1][i - 1], dp[2][i - 1]); dp[1][i] = costs[i][1] + Math.min(dp[0][i - 1], dp[2][i - 1]); dp[2][i] = costs[i][2] + Math.min(dp[0][i - 1], dp[1][i - 1]); Solution I class Solution { public int minCost ( int [][] costs ) { if ( costs == null || costs . length == 0 || costs [ 0 ] == null || costs [ 0 ]. length == 0 ) return 0 ; int n = costs . length ; int [][] dp = new int [ 3 ][ n ]; dp [ 0 ][ 0 ] = costs [ 0 ][ 0 ]; dp [ 1 ][ 0 ] = costs [ 0 ][ 1 ]; dp [ 2 ][ 0 ] = costs [ 0 ][ 2 ]; for ( int i = 1 ; i n ; i ++) { dp [ 0 ][ i ] = costs [ i ][ 0 ] + Math . min ( dp [ 1 ][ i - 1 ], dp [ 2 ][ i - 1 ]); dp [ 1 ][ i ] = costs [ i ][ 1 ] + Math . min ( dp [ 0 ][ i - 1 ], dp [ 2 ][ i - 1 ]); dp [ 2 ][ i ] = costs [ i ][ 2 ] + Math . min ( dp [ 0 ][ i - 1 ], dp [ 1 ][ i - 1 ]); } return Math . min ( dp [ 0 ][ n - 1 ], Math . min ( dp [ 1 ][ n - 1 ], dp [ 2 ][ n - 1 ])); } } Optimized p1 = costs[i][0] + Math.min(t2, t3); p2 = costs[i][1] + Math.min(t1, t3); p3 = costs[i][2] + Math.min(t1, t2); Solution II class Solution { public int minCost ( int [][] costs ) { if ( costs == null || costs . length == 0 || costs [ 0 ] == null || costs [ 0 ]. length == 0 ) return 0 ; int n = costs . length ; int p1 = costs [ 0 ][ 0 ], p2 = costs [ 0 ][ 1 ], p3 = costs [ 0 ][ 2 ]; for ( int i = 1 ; i n ; i ++) { int t1 = p1 , t2 = p2 , t3 = p3 ; p1 = costs [ i ][ 0 ] + Math . min ( t2 , t3 ); p2 = costs [ i ][ 1 ] + Math . min ( t1 , t3 ); p3 = costs [ i ][ 2 ] + Math . min ( t1 , t2 ); } return Math . min ( p1 , Math . min ( p2 , p3 )); } }","title":"Paint House I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states08/#multiple-states-viii","text":"","title":"Multiple States VIII"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states08/#description","text":"There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses. Note: All costs are positive integers.","title":"Description"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states08/#question-link","text":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states08/#example-i","text":"Input: [[17,2,17],[16,16,5],[14,3,19]] Output: 10 Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue. Minimum cost: 2 + 5 + 3 = 10.","title":"Example I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states08/#questions","text":"LeetCode - 256. Paint House","title":"Questions"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states08/#transform-function","text":"dp[0][i] = costs[i][0] + Math.min(dp[1][i - 1], dp[2][i - 1]); dp[1][i] = costs[i][1] + Math.min(dp[0][i - 1], dp[2][i - 1]); dp[2][i] = costs[i][2] + Math.min(dp[0][i - 1], dp[1][i - 1]);","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states08/#solution-i","text":"class Solution { public int minCost ( int [][] costs ) { if ( costs == null || costs . length == 0 || costs [ 0 ] == null || costs [ 0 ]. length == 0 ) return 0 ; int n = costs . length ; int [][] dp = new int [ 3 ][ n ]; dp [ 0 ][ 0 ] = costs [ 0 ][ 0 ]; dp [ 1 ][ 0 ] = costs [ 0 ][ 1 ]; dp [ 2 ][ 0 ] = costs [ 0 ][ 2 ]; for ( int i = 1 ; i n ; i ++) { dp [ 0 ][ i ] = costs [ i ][ 0 ] + Math . min ( dp [ 1 ][ i - 1 ], dp [ 2 ][ i - 1 ]); dp [ 1 ][ i ] = costs [ i ][ 1 ] + Math . min ( dp [ 0 ][ i - 1 ], dp [ 2 ][ i - 1 ]); dp [ 2 ][ i ] = costs [ i ][ 2 ] + Math . min ( dp [ 0 ][ i - 1 ], dp [ 1 ][ i - 1 ]); } return Math . min ( dp [ 0 ][ n - 1 ], Math . min ( dp [ 1 ][ n - 1 ], dp [ 2 ][ n - 1 ])); } }","title":"Solution I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states08/#optimized","text":"p1 = costs[i][0] + Math.min(t2, t3); p2 = costs[i][1] + Math.min(t1, t3); p3 = costs[i][2] + Math.min(t1, t2);","title":"Optimized"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states08/#solution-ii","text":"class Solution { public int minCost ( int [][] costs ) { if ( costs == null || costs . length == 0 || costs [ 0 ] == null || costs [ 0 ]. length == 0 ) return 0 ; int n = costs . length ; int p1 = costs [ 0 ][ 0 ], p2 = costs [ 0 ][ 1 ], p3 = costs [ 0 ][ 2 ]; for ( int i = 1 ; i n ; i ++) { int t1 = p1 , t2 = p2 , t3 = p3 ; p1 = costs [ i ][ 0 ] + Math . min ( t2 , t3 ); p2 = costs [ i ][ 1 ] + Math . min ( t1 , t3 ); p3 = costs [ i ][ 2 ] + Math . min ( t1 , t2 ); } return Math . min ( p1 , Math . min ( p2 , p3 )); } }","title":"Solution II"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states09/","text":"Multiple States IX Description There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses. Note: All costs are positive integers. Question Link https://leetcode.com/problems/paint-house-ii/description/ Example I Input: [[1,5,3],[2,9,4]] Output: 5 Explanation: Paint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; Or paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5. Questions LeetCode - 265. Paint House II Transform Function if(k != i) dp[i][j] = Math.min(dp[i][j], costs[j][i] + dp[k][j - 1]); Solution I class Solution { public int minCostII ( int [][] costs ) { if ( costs == null || costs . length == 0 || costs [ 0 ] == null || costs [ 0 ]. length == 0 ) return 0 ; int n = costs . length , m = costs [ 0 ]. length ; int [][] dp = new int [ m + 1 ][ n + 1 ]; for ( int [] row : dp ) Arrays . fill ( row , Integer . MAX_VALUE ); for ( int i = 0 ; i = m ; i ++) dp [ i ][ 0 ] = 0 ; for ( int j = 1 ; j = n ; j ++) { for ( int i = 1 ; i = m ; i ++) { for ( int k = ( j == 1 ? 0 : 1 ); k = m ; k ++) { if ( k != i ) dp [ i ][ j ] = Math . min ( dp [ i ][ j ], costs [ j - 1 ][ i - 1 ] + dp [ k ][ j - 1 ]); } } } int res = Integer . MAX_VALUE ; for ( int i = 0 ; i = m ; i ++) res = Math . min ( dp [ i ][ n ], res ); return res ; } } Optimized c = cost[i] + (last == i ? min2 : min1); Solution II class Solution { public int minCostII ( int [][] costs ) { if ( costs == null || costs . length == 0 || costs [ 0 ] == null || costs [ 0 ]. length == 0 ) return 0 ; int min1 = 0 , min2 = 0 , last = - 1 ; for ( int [] cost : costs ) { int curMin1 = Integer . MAX_VALUE ; int curMin2 = Integer . MAX_VALUE ; int cur = - 1 ; for ( int i = 0 ; i cost . length ; i ++) { int c = cost [ i ] + ( last == i ? min2 : min1 ); if ( c curMin1 ) { curMin2 = curMin1 ; cur = i ; curMin1 = c ; } else if ( c curMin2 ) { curMin2 = c ; } } min1 = curMin1 ; min2 = curMin2 ; last = cur ; } return min1 ; } }","title":"Paint House II"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states09/#multiple-states-ix","text":"","title":"Multiple States IX"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states09/#description","text":"There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses. Note: All costs are positive integers.","title":"Description"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states09/#question-link","text":"https://leetcode.com/problems/paint-house-ii/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states09/#example-i","text":"Input: [[1,5,3],[2,9,4]] Output: 5 Explanation: Paint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; Or paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.","title":"Example I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states09/#questions","text":"LeetCode - 265. Paint House II","title":"Questions"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states09/#transform-function","text":"if(k != i) dp[i][j] = Math.min(dp[i][j], costs[j][i] + dp[k][j - 1]);","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states09/#solution-i","text":"class Solution { public int minCostII ( int [][] costs ) { if ( costs == null || costs . length == 0 || costs [ 0 ] == null || costs [ 0 ]. length == 0 ) return 0 ; int n = costs . length , m = costs [ 0 ]. length ; int [][] dp = new int [ m + 1 ][ n + 1 ]; for ( int [] row : dp ) Arrays . fill ( row , Integer . MAX_VALUE ); for ( int i = 0 ; i = m ; i ++) dp [ i ][ 0 ] = 0 ; for ( int j = 1 ; j = n ; j ++) { for ( int i = 1 ; i = m ; i ++) { for ( int k = ( j == 1 ? 0 : 1 ); k = m ; k ++) { if ( k != i ) dp [ i ][ j ] = Math . min ( dp [ i ][ j ], costs [ j - 1 ][ i - 1 ] + dp [ k ][ j - 1 ]); } } } int res = Integer . MAX_VALUE ; for ( int i = 0 ; i = m ; i ++) res = Math . min ( dp [ i ][ n ], res ); return res ; } }","title":"Solution I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states09/#optimized","text":"c = cost[i] + (last == i ? min2 : min1);","title":"Optimized"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states09/#solution-ii","text":"class Solution { public int minCostII ( int [][] costs ) { if ( costs == null || costs . length == 0 || costs [ 0 ] == null || costs [ 0 ]. length == 0 ) return 0 ; int min1 = 0 , min2 = 0 , last = - 1 ; for ( int [] cost : costs ) { int curMin1 = Integer . MAX_VALUE ; int curMin2 = Integer . MAX_VALUE ; int cur = - 1 ; for ( int i = 0 ; i cost . length ; i ++) { int c = cost [ i ] + ( last == i ? min2 : min1 ); if ( c curMin1 ) { curMin2 = curMin1 ; cur = i ; curMin1 = c ; } else if ( c curMin2 ) { curMin2 = c ; } } min1 = curMin1 ; min2 = curMin2 ; last = cur ; } return min1 ; } }","title":"Solution II"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states10/","text":"Multiple States X Description There is a fence with n posts, each post can be painted with one of the k colors. You have to paint all the posts such that no more than two adjacent fence posts have the same color. Return the total number of ways you can paint the fence. Note: n and k are non-negative integers. Question Link https://leetcode.com/problems/paint-fence/description/ Example I Input: n = 3, k = 2 Output: 6 Explanation: Take c1 as color 1, c2 as color 2. All possible ways are: post1 post2 post3 ----- ----- ----- ----- 1 c1 c1 c2 2 c1 c2 c1 3 c1 c2 c2 4 c2 c1 c1 5 c2 c1 c2 6 c2 c2 c1 Questions LeetCode - 276. Paint Fence Transform Function dp1[i] = dp2[i - 1]; // same color dp2[i] = (k - 1) * (dp1[i - 1] + dp2[i - 1]); // not same color Solution I class Solution { public int numWays ( int n , int k ) { if ( n == 0 ) return 0 ; int [] dp1 = new int [ n + 1 ]; int [] dp2 = new int [ n + 1 ]; dp2 [ 1 ] = k ; for ( int i = 2 ; i = n ; i ++) { dp1 [ i ] = dp2 [ i - 1 ]; dp2 [ i ] = ( k - 1 ) * ( dp1 [ i - 1 ] + dp2 [ i - 1 ]); } return dp1 [ n ] + dp2 [ n ]; } }","title":"Paint Fence"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states10/#multiple-states-x","text":"","title":"Multiple States X"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states10/#description","text":"There is a fence with n posts, each post can be painted with one of the k colors. You have to paint all the posts such that no more than two adjacent fence posts have the same color. Return the total number of ways you can paint the fence. Note: n and k are non-negative integers.","title":"Description"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states10/#question-link","text":"https://leetcode.com/problems/paint-fence/description/","title":"Question Link"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states10/#example-i","text":"Input: n = 3, k = 2 Output: 6 Explanation: Take c1 as color 1, c2 as color 2. All possible ways are: post1 post2 post3 ----- ----- ----- ----- 1 c1 c1 c2 2 c1 c2 c1 3 c1 c2 c2 4 c2 c1 c1 5 c2 c1 c2 6 c2 c2 c1","title":"Example I"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states10/#questions","text":"LeetCode - 276. Paint Fence","title":"Questions"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states10/#transform-function","text":"dp1[i] = dp2[i - 1]; // same color dp2[i] = (k - 1) * (dp1[i - 1] + dp2[i - 1]); // not same color","title":"Transform Function"},{"location":"Algorithm/DynamicProgramming/MultipleStates/multiple_states10/#solution-i","text":"class Solution { public int numWays ( int n , int k ) { if ( n == 0 ) return 0 ; int [] dp1 = new int [ n + 1 ]; int [] dp2 = new int [ n + 1 ]; dp2 [ 1 ] = k ; for ( int i = 2 ; i = n ; i ++) { dp1 [ i ] = dp2 [ i - 1 ]; dp2 [ i ] = ( k - 1 ) * ( dp1 [ i - 1 ] + dp2 [ i - 1 ]); } return dp1 [ n ] + dp2 [ n ]; } }","title":"Solution I"},{"location":"Algorithm/LineSweep/line_sweep01/","text":"Line Sweep I Description A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 \u2264 Li, Ri \u2264 INT_MAX, 0 Hi \u2264 INT_MAX, and Ri - Li 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] . The output is a list of \"key points\" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour. For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]. Notes: - The number of buildings in any input list is guaranteed to be in the range [0, 10000]. - The input list is already sorted in ascending order by the left x position Li. - The output list must be sorted by the x position. - There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...] Question Link https://leetcode.com/problems/the-skyline-problem/description/ Questions LeetCode - 218. The Skyline Problem Analysis entrance points: - not points in heap - higher than the second points in heap (means higher than the second square) leave points: - higher than the second points in heap (means higher than the second square) - not more short points (means the right-bottom point of a square) Solution I class Solution { public List List Integer getSkyline ( int [][] buildings ) { List int [] points = new ArrayList (); for ( int [] p : buildings ) { points . add ( new int []{ p [ 0 ], - p [ 2 ]}); points . add ( new int []{ p [ 1 ], p [ 2 ]}); } Collections . sort ( points , ( a , b ) - ( a [ 0 ] == b [ 0 ] ? a [ 1 ] - b [ 1 ] : a [ 0 ] - b [ 0 ])); List List Integer res = new ArrayList (); TreeMap Integer , Integer tree = new TreeMap (); tree . put ( 0 , 1 ); for ( int [] p : points ) { int h = Math . abs ( p [ 1 ]); if ( p [ 1 ] 0 ) { tree . put ( h , tree . get ( h ) - 1 ); if ( tree . get ( h ) == 0 ) tree . remove ( h ); if ( h tree . lastKey ()) res . add ( Arrays . asList ( p [ 0 ], tree . isEmpty () ? 0 : tree . lastKey ())); } else { if ( tree . isEmpty () || h tree . lastKey ()) res . add ( Arrays . asList ( p [ 0 ], h )); tree . put ( h , tree . getOrDefault ( h , 0 ) + 1 ); } } return res ; } } Analysis II smaller x with max h currently Solution II class Solution { public List List Integer getSkyline ( int [][] buildings ) { if ( buildings == null || buildings . length == 0 ) return new LinkedList List Integer (); return mergeSort ( buildings , 0 , buildings . length - 1 ); } private LinkedList List Integer mergeSort ( int [][] buildings , int l , int r ) { if ( l == r ) { LinkedList List Integer list = new LinkedList (); list . add ( Arrays . asList ( buildings [ l ][ 0 ], buildings [ l ][ 2 ])); list . add ( Arrays . asList ( buildings [ l ][ 1 ], 0 )); return list ; } else { int m = l + ( r - l ) / 2 ; return merge ( mergeSort ( buildings , l , m ), mergeSort ( buildings , m + 1 , r )); } } private LinkedList List Integer merge ( LinkedList List Integer l1 , LinkedList List Integer l2 ) { LinkedList List Integer res = new LinkedList (); int max_h = 0 , l1_h = 0 , l2_h = 0 , x ; while (! l1 . isEmpty () ! l2 . isEmpty ()) { if ( l1 . getFirst (). get ( 0 ) l2 . getFirst (). get ( 0 )) { x = l1 . getFirst (). get ( 0 ); l1_h = l1 . getFirst (). get ( 1 ); max_h = Math . max ( l1_h , l2_h ); l1 . removeFirst (); } else if ( l1 . getFirst (). get ( 0 ) l2 . getFirst (). get ( 0 )) { x = l2 . getFirst (). get ( 0 ); l2_h = l2 . getFirst (). get ( 1 ); max_h = Math . max ( l1_h , l2_h ); l2 . removeFirst (); } else { x = l1 . getFirst (). get ( 0 ); l1_h = l1 . getFirst (). get ( 1 ); l2_h = l2 . getFirst (). get ( 1 ); max_h = Math . max ( l1_h , l2_h ); l1 . removeFirst (); l2 . removeFirst (); } if ( res . isEmpty () || max_h != res . getLast (). get ( 1 )) { res . add ( Arrays . asList ( x , max_h )); } } res . addAll ( l1 ); res . addAll ( l2 ); return res ; } }","title":"The Skyline Problem"},{"location":"Algorithm/LineSweep/line_sweep01/#line-sweep-i","text":"","title":"Line Sweep I"},{"location":"Algorithm/LineSweep/line_sweep01/#description","text":"A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 \u2264 Li, Ri \u2264 INT_MAX, 0 Hi \u2264 INT_MAX, and Ri - Li 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] . The output is a list of \"key points\" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour. For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]. Notes: - The number of buildings in any input list is guaranteed to be in the range [0, 10000]. - The input list is already sorted in ascending order by the left x position Li. - The output list must be sorted by the x position. - There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]","title":"Description"},{"location":"Algorithm/LineSweep/line_sweep01/#question-link","text":"https://leetcode.com/problems/the-skyline-problem/description/","title":"Question Link"},{"location":"Algorithm/LineSweep/line_sweep01/#questions","text":"LeetCode - 218. The Skyline Problem","title":"Questions"},{"location":"Algorithm/LineSweep/line_sweep01/#analysis","text":"entrance points: - not points in heap - higher than the second points in heap (means higher than the second square) leave points: - higher than the second points in heap (means higher than the second square) - not more short points (means the right-bottom point of a square)","title":"Analysis"},{"location":"Algorithm/LineSweep/line_sweep01/#solution-i","text":"class Solution { public List List Integer getSkyline ( int [][] buildings ) { List int [] points = new ArrayList (); for ( int [] p : buildings ) { points . add ( new int []{ p [ 0 ], - p [ 2 ]}); points . add ( new int []{ p [ 1 ], p [ 2 ]}); } Collections . sort ( points , ( a , b ) - ( a [ 0 ] == b [ 0 ] ? a [ 1 ] - b [ 1 ] : a [ 0 ] - b [ 0 ])); List List Integer res = new ArrayList (); TreeMap Integer , Integer tree = new TreeMap (); tree . put ( 0 , 1 ); for ( int [] p : points ) { int h = Math . abs ( p [ 1 ]); if ( p [ 1 ] 0 ) { tree . put ( h , tree . get ( h ) - 1 ); if ( tree . get ( h ) == 0 ) tree . remove ( h ); if ( h tree . lastKey ()) res . add ( Arrays . asList ( p [ 0 ], tree . isEmpty () ? 0 : tree . lastKey ())); } else { if ( tree . isEmpty () || h tree . lastKey ()) res . add ( Arrays . asList ( p [ 0 ], h )); tree . put ( h , tree . getOrDefault ( h , 0 ) + 1 ); } } return res ; } }","title":"Solution I"},{"location":"Algorithm/LineSweep/line_sweep01/#analysis-ii","text":"smaller x with max h currently","title":"Analysis II"},{"location":"Algorithm/LineSweep/line_sweep01/#solution-ii","text":"class Solution { public List List Integer getSkyline ( int [][] buildings ) { if ( buildings == null || buildings . length == 0 ) return new LinkedList List Integer (); return mergeSort ( buildings , 0 , buildings . length - 1 ); } private LinkedList List Integer mergeSort ( int [][] buildings , int l , int r ) { if ( l == r ) { LinkedList List Integer list = new LinkedList (); list . add ( Arrays . asList ( buildings [ l ][ 0 ], buildings [ l ][ 2 ])); list . add ( Arrays . asList ( buildings [ l ][ 1 ], 0 )); return list ; } else { int m = l + ( r - l ) / 2 ; return merge ( mergeSort ( buildings , l , m ), mergeSort ( buildings , m + 1 , r )); } } private LinkedList List Integer merge ( LinkedList List Integer l1 , LinkedList List Integer l2 ) { LinkedList List Integer res = new LinkedList (); int max_h = 0 , l1_h = 0 , l2_h = 0 , x ; while (! l1 . isEmpty () ! l2 . isEmpty ()) { if ( l1 . getFirst (). get ( 0 ) l2 . getFirst (). get ( 0 )) { x = l1 . getFirst (). get ( 0 ); l1_h = l1 . getFirst (). get ( 1 ); max_h = Math . max ( l1_h , l2_h ); l1 . removeFirst (); } else if ( l1 . getFirst (). get ( 0 ) l2 . getFirst (). get ( 0 )) { x = l2 . getFirst (). get ( 0 ); l2_h = l2 . getFirst (). get ( 1 ); max_h = Math . max ( l1_h , l2_h ); l2 . removeFirst (); } else { x = l1 . getFirst (). get ( 0 ); l1_h = l1 . getFirst (). get ( 1 ); l2_h = l2 . getFirst (). get ( 1 ); max_h = Math . max ( l1_h , l2_h ); l1 . removeFirst (); l2 . removeFirst (); } if ( res . isEmpty () || max_h != res . getLast (). get ( 1 )) { res . add ( Arrays . asList ( x , max_h )); } } res . addAll ( l1 ); res . addAll ( l2 ); return res ; } }","title":"Solution II"},{"location":"LeetCode/lc0001/","text":"1. Two Sum Description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Java public int [] twoSum ( int [] nums , int target ) { HashMap Integer , Integer map = new HashMap (); for ( int i = 0 ; i nums . length ; i ++) { if ( map . containsKey ( target - nums [ i ]) map . get ( target - nums [ i ]) != i ) { return new int []{ map . get ( target - nums [ i ]), i }; } map . put ( nums [ i ], i ); } return new int []{}; } JavaScript var twoSum = function ( nums , target ) { var res = []; var map = new Map (); for ( var i = 0 ; i nums . length ; i ++ ) { if ( map . has ( target - nums [ i ])) { res . push ( map . get ( target - nums [ i ])); res . push ( i ); return res ; } map . set ( nums [ i ], i ); } return res ; } C++ public : vector int twoSum ( vector int nums , int target ) { unordered_map int , int map ; for ( int i = 0 ; i nums . size (); i ++ ) { if ( map . count ( target - nums [ i ])) { return { map [ target - nums [ i ]], i }; } map [ nums [ i ]] = i ; } return {}; } C struct node { int key ; int val ; int count ; struct node * next ; }; struct table { int size ; struct node ** list ; }; struct table * createTable ( int size ) { struct table * t = ( struct table * ) malloc ( sizeof ( struct table )); t - size = size ; t - list = ( struct node ** ) malloc ( sizeof ( struct node * ) * size ); for ( int i = 0 ; i size ; i ++ ) { t - list [ i ] = NULL ; } return t ; } int hashCode ( struct table * t , int key ) { if ( key 0 ) return - ( key % t - size ); return key % t - size ; } void insert ( struct table * t , int key , int val ) { int pos = hashCode ( t , key ); struct node * list = t - list [ pos ]; struct node * newNode = ( struct node * ) malloc ( sizeof ( struct node )); struct node * temp = list ; while ( temp ) { if ( temp - key == key ){ temp - count = temp - count + 1 ; return ; } temp = temp - next ; } newNode - key = key ; newNode - val = val ; newNode - count = 1 ; newNode - next = list ; t - list [ pos ] = newNode ; return ; } int search ( struct table * t , int key ) { int pos = hashCode ( t , key ); struct node * list = t - list [ pos ]; struct node * temp = list ; while ( temp ) { if ( temp - key == key ) { return temp - val ; } temp = temp - next ; } return - 1 ; } int * twoSum ( int * nums , int numsSize , int target ) { int * res = malloc ( sizeof ( int ) * 2 ); struct table * t = createTable ( numsSize ); for ( int i = 0 ; i numsSize ; i ++ ) { int pos = search ( t , target - nums [ i ]); if ( pos - 1 ) { res [ 0 ] = pos ; res [ 1 ] = i ; return res ; } insert ( t , nums [ i ], i ); } return res ; }","title":"1 Two Sum"},{"location":"LeetCode/lc0001/#1-two-sum","text":"","title":"1. Two Sum"},{"location":"LeetCode/lc0001/#description","text":"Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.","title":"Description"},{"location":"LeetCode/lc0001/#example","text":"Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].","title":"Example"},{"location":"LeetCode/lc0001/#java","text":"public int [] twoSum ( int [] nums , int target ) { HashMap Integer , Integer map = new HashMap (); for ( int i = 0 ; i nums . length ; i ++) { if ( map . containsKey ( target - nums [ i ]) map . get ( target - nums [ i ]) != i ) { return new int []{ map . get ( target - nums [ i ]), i }; } map . put ( nums [ i ], i ); } return new int []{}; }","title":"Java"},{"location":"LeetCode/lc0001/#javascript","text":"var twoSum = function ( nums , target ) { var res = []; var map = new Map (); for ( var i = 0 ; i nums . length ; i ++ ) { if ( map . has ( target - nums [ i ])) { res . push ( map . get ( target - nums [ i ])); res . push ( i ); return res ; } map . set ( nums [ i ], i ); } return res ; }","title":"JavaScript"},{"location":"LeetCode/lc0001/#c","text":"public : vector int twoSum ( vector int nums , int target ) { unordered_map int , int map ; for ( int i = 0 ; i nums . size (); i ++ ) { if ( map . count ( target - nums [ i ])) { return { map [ target - nums [ i ]], i }; } map [ nums [ i ]] = i ; } return {}; }","title":"C++"},{"location":"LeetCode/lc0001/#c_1","text":"struct node { int key ; int val ; int count ; struct node * next ; }; struct table { int size ; struct node ** list ; }; struct table * createTable ( int size ) { struct table * t = ( struct table * ) malloc ( sizeof ( struct table )); t - size = size ; t - list = ( struct node ** ) malloc ( sizeof ( struct node * ) * size ); for ( int i = 0 ; i size ; i ++ ) { t - list [ i ] = NULL ; } return t ; } int hashCode ( struct table * t , int key ) { if ( key 0 ) return - ( key % t - size ); return key % t - size ; } void insert ( struct table * t , int key , int val ) { int pos = hashCode ( t , key ); struct node * list = t - list [ pos ]; struct node * newNode = ( struct node * ) malloc ( sizeof ( struct node )); struct node * temp = list ; while ( temp ) { if ( temp - key == key ){ temp - count = temp - count + 1 ; return ; } temp = temp - next ; } newNode - key = key ; newNode - val = val ; newNode - count = 1 ; newNode - next = list ; t - list [ pos ] = newNode ; return ; } int search ( struct table * t , int key ) { int pos = hashCode ( t , key ); struct node * list = t - list [ pos ]; struct node * temp = list ; while ( temp ) { if ( temp - key == key ) { return temp - val ; } temp = temp - next ; } return - 1 ; } int * twoSum ( int * nums , int numsSize , int target ) { int * res = malloc ( sizeof ( int ) * 2 ); struct table * t = createTable ( numsSize ); for ( int i = 0 ; i numsSize ; i ++ ) { int pos = search ( t , target - nums [ i ]); if ( pos - 1 ) { res [ 0 ] = pos ; res [ 1 ] = i ; return res ; } insert ( t , nums [ i ], i ); } return res ; }","title":"C"},{"location":"LeetCode/lc0101/","text":"101. Symmetric Tree Description Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). Example For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3 Java(Recursive) public boolean isSymmetric ( TreeNode root ) { if ( root == null ) return true ; return helper ( root . left , root . right ); } boolean helper ( TreeNode left , TreeNode right ) { if ( left == null right == null ) return true ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; boolean temp = true ; return temp helper ( left . left , right . right ) helper ( left . right , right . left ); } Java(Iterative) public boolean isSymmetric ( TreeNode root ) { Queue TreeNode queue = new LinkedList (); queue . offer ( root ); queue . offer ( root ); while (! queue . isEmpty ()) { TreeNode left = queue . poll (); TreeNode right = queue . poll (); if ( left == null right == null ) continue ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; queue . offer ( left . left ); queue . offer ( right . right ); queue . offer ( left . right ); queue . offer ( right . left ); } return true ; } JavaScript var isSymmetric = function ( root ) { if ( root == null ) return true ; return helper ( root . left , root . right ); }; function helper ( left , right ) { if ( left == null right == null ) return true ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; return helper ( left . left , right . right ) helper ( left . right , right . left ); } C++ public : bool isSymmetric ( TreeNode * root ) { if ( ! root ) return true ; return helper ( root - left , root - right ); } public : bool helper ( TreeNode * left , TreeNode * right ) { if ( ! left ! right ) return true ; if ( ! left || ! right ) return false ; if ( left - val != right - val ) return false ; return helper ( left - left , right - right ) helper ( left - right , right - left ); }","title":"101 Symmetric Tree"},{"location":"LeetCode/lc0101/#101-symmetric-tree","text":"","title":"101. Symmetric Tree"},{"location":"LeetCode/lc0101/#description","text":"Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).","title":"Description"},{"location":"LeetCode/lc0101/#example","text":"For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3","title":"Example"},{"location":"LeetCode/lc0101/#javarecursive","text":"public boolean isSymmetric ( TreeNode root ) { if ( root == null ) return true ; return helper ( root . left , root . right ); } boolean helper ( TreeNode left , TreeNode right ) { if ( left == null right == null ) return true ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; boolean temp = true ; return temp helper ( left . left , right . right ) helper ( left . right , right . left ); }","title":"Java(Recursive)"},{"location":"LeetCode/lc0101/#javaiterative","text":"public boolean isSymmetric ( TreeNode root ) { Queue TreeNode queue = new LinkedList (); queue . offer ( root ); queue . offer ( root ); while (! queue . isEmpty ()) { TreeNode left = queue . poll (); TreeNode right = queue . poll (); if ( left == null right == null ) continue ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; queue . offer ( left . left ); queue . offer ( right . right ); queue . offer ( left . right ); queue . offer ( right . left ); } return true ; }","title":"Java(Iterative)"},{"location":"LeetCode/lc0101/#javascript","text":"var isSymmetric = function ( root ) { if ( root == null ) return true ; return helper ( root . left , root . right ); }; function helper ( left , right ) { if ( left == null right == null ) return true ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; return helper ( left . left , right . right ) helper ( left . right , right . left ); }","title":"JavaScript"},{"location":"LeetCode/lc0101/#c","text":"public : bool isSymmetric ( TreeNode * root ) { if ( ! root ) return true ; return helper ( root - left , root - right ); } public : bool helper ( TreeNode * left , TreeNode * right ) { if ( ! left ! right ) return true ; if ( ! left || ! right ) return false ; if ( left - val != right - val ) return false ; return helper ( left - left , right - right ) helper ( left - right , right - left ); }","title":"C++"},{"location":"LeetCode/lc0282/","text":"282. Expression Add Operators Description Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. Example 1. Input: num = 123 , target = 6 Output: [ 1+2+3 , 1*2*3 ] 2. Input: num = 232 , target = 8 Output: [ 2*3+2 , 2+3*2 ] 3. Input: num = 105 , target = 5 Output: [ 1*0+5 , 10-5 ] 4. Input: num = 00 , target = 0 Output: [ 0+0 , 0-0 , 0*0 ] 5. Input: num = 3456237490 , target = 9191 Output: [] Java public List String addOperators ( String num , int target ) { List String res = new ArrayList (); if ( num == null || num . length () == 0 ) return res ; helper ( num , , 0 , 0 , 0 , target , res ); return res ; } public void helper ( String num , String temp , int pos , long cur , long prev , int target , List String res ) { if ( pos == num . length ()) { if ( cur == target ) { res . add ( temp ); } return ; } for ( int i = pos ; i num . length (); i ++) { if ( i != pos num . charAt ( pos ) == 0 ) break ; long t = Long . parseLong ( num . substring ( pos , i + 1 )); if ( pos == 0 ) { helper ( num , temp + t , i + 1 , t , t , target , res ); } else { helper ( num , temp + + + t , i + 1 , cur + t , t , target , res ); helper ( num , temp + - + t , i + 1 , cur - t , - t , target , res ); helper ( num , temp + * + t , i + 1 , cur - prev + t * prev , t * prev , target , res ); } } } JavaScript var addOperators = function ( num , target ) { var res = []; helper ( num , , 0 , 0 , 0 , target , res ); return res ; }; function helper ( num , temp , pos , cur , prev , target , res ) { if ( pos === num . length ) { if ( cur === target ) { res . push ( temp ); } return ; } for ( let i = pos ; i num . length ; i ++ ) { if ( i != pos num . charAt ( pos ) == 0 ) break ; let n = parseInt ( num . substring ( pos , i + 1 )); if ( pos == 0 ) { helper ( num , + n , i + 1 , n , n , target , res ); } else { helper ( num , temp + + + n , i + 1 , cur + n , n , target , res ); helper ( num , temp + - + n , i + 1 , cur - n , - n , target , res ); helper ( num , temp + * + n , i + 1 , cur - prev + n * prev , n * prev , target , res ); } } } C++ public : vector string addOperators ( string num , int target ) { vector string res ; helper ( num , , 0 , 0 , 0 , target , res ); return res ; } private : void helper ( string num , string temp , int pos , long cur , long prev , int target , vector string res ) { if ( pos == num . size ()) { if ( cur == target ) { res . push_back ( temp ); } return ; } for ( int i = pos ; i num . size (); i ++ ) { if ( i != pos num [ pos ] == 0 ) break ; string n = num . substr ( pos , i - pos + 1 ); if ( pos == 0 ) { helper ( num , + n , i + 1 , stoll ( n ), stoll ( n ), target , res ); } else { helper ( num , temp + + + n , i + 1 , cur + stoll ( n ), stoll ( n ), target , res ); helper ( num , temp + - + n , i + 1 , cur - stoll ( n ), - stoll ( n ), target , res ); helper ( num , temp + * + n , i + 1 , cur - prev + prev * stoll ( n ), prev * stoll ( n ), target , res ); } } }","title":"282 Expression Add Operators"},{"location":"LeetCode/lc0282/#282-expression-add-operators","text":"","title":"282. Expression Add Operators"},{"location":"LeetCode/lc0282/#description","text":"Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.","title":"Description"},{"location":"LeetCode/lc0282/#example","text":"1. Input: num = 123 , target = 6 Output: [ 1+2+3 , 1*2*3 ] 2. Input: num = 232 , target = 8 Output: [ 2*3+2 , 2+3*2 ] 3. Input: num = 105 , target = 5 Output: [ 1*0+5 , 10-5 ] 4. Input: num = 00 , target = 0 Output: [ 0+0 , 0-0 , 0*0 ] 5. Input: num = 3456237490 , target = 9191 Output: []","title":"Example"},{"location":"LeetCode/lc0282/#java","text":"public List String addOperators ( String num , int target ) { List String res = new ArrayList (); if ( num == null || num . length () == 0 ) return res ; helper ( num , , 0 , 0 , 0 , target , res ); return res ; } public void helper ( String num , String temp , int pos , long cur , long prev , int target , List String res ) { if ( pos == num . length ()) { if ( cur == target ) { res . add ( temp ); } return ; } for ( int i = pos ; i num . length (); i ++) { if ( i != pos num . charAt ( pos ) == 0 ) break ; long t = Long . parseLong ( num . substring ( pos , i + 1 )); if ( pos == 0 ) { helper ( num , temp + t , i + 1 , t , t , target , res ); } else { helper ( num , temp + + + t , i + 1 , cur + t , t , target , res ); helper ( num , temp + - + t , i + 1 , cur - t , - t , target , res ); helper ( num , temp + * + t , i + 1 , cur - prev + t * prev , t * prev , target , res ); } } }","title":"Java"},{"location":"LeetCode/lc0282/#javascript","text":"var addOperators = function ( num , target ) { var res = []; helper ( num , , 0 , 0 , 0 , target , res ); return res ; }; function helper ( num , temp , pos , cur , prev , target , res ) { if ( pos === num . length ) { if ( cur === target ) { res . push ( temp ); } return ; } for ( let i = pos ; i num . length ; i ++ ) { if ( i != pos num . charAt ( pos ) == 0 ) break ; let n = parseInt ( num . substring ( pos , i + 1 )); if ( pos == 0 ) { helper ( num , + n , i + 1 , n , n , target , res ); } else { helper ( num , temp + + + n , i + 1 , cur + n , n , target , res ); helper ( num , temp + - + n , i + 1 , cur - n , - n , target , res ); helper ( num , temp + * + n , i + 1 , cur - prev + n * prev , n * prev , target , res ); } } }","title":"JavaScript"},{"location":"LeetCode/lc0282/#c","text":"public : vector string addOperators ( string num , int target ) { vector string res ; helper ( num , , 0 , 0 , 0 , target , res ); return res ; } private : void helper ( string num , string temp , int pos , long cur , long prev , int target , vector string res ) { if ( pos == num . size ()) { if ( cur == target ) { res . push_back ( temp ); } return ; } for ( int i = pos ; i num . size (); i ++ ) { if ( i != pos num [ pos ] == 0 ) break ; string n = num . substr ( pos , i - pos + 1 ); if ( pos == 0 ) { helper ( num , + n , i + 1 , stoll ( n ), stoll ( n ), target , res ); } else { helper ( num , temp + + + n , i + 1 , cur + stoll ( n ), stoll ( n ), target , res ); helper ( num , temp + - + n , i + 1 , cur - stoll ( n ), - stoll ( n ), target , res ); helper ( num , temp + * + n , i + 1 , cur - prev + prev * stoll ( n ), prev * stoll ( n ), target , res ); } } }","title":"C++"},{"location":"LeetCode/lc0339/","text":"399. Evaluate Division Description Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0. Example Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . return [6.0, 0.5, -1.0, 1.0, -1.0 ]. The input is: vector equations, vector values, vector queries ,where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector . According to the example above: equations = [ [ a , b ], [ b , c ] ], values = [2.0, 3.0], queries = [ [ a , c ], [ b , a ], [ a , e ], [ a , a ], [ x , x ] ]. Java(DFS) Map String , Map String , Double map ; public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { map = new HashMap (); for ( int i = 0 ; i equations . length ; i ++) { String x = equations [ i ][ 0 ]; String y = equations [ i ][ 1 ]; double value = values [ i ]; map . putIfAbsent ( x , new HashMap String , Double ()); map . putIfAbsent ( y , new HashMap String , Double ()); map . get ( x ). put ( y , value ); map . get ( y ). put ( x , 1.0 / value ); } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { if (! map . containsKey ( queries [ i ][ 0 ]) || ! map . containsKey ( queries [ i ][ 0 ])) res [ i ] = - 1.0 ; else res [ i ] = dfs ( queries [ i ][ 0 ], queries [ i ][ 1 ], new HashSet String ()); } return res ; } double dfs ( String cur , String target , Set String set ) { if ( cur . equals ( target )) return 1.0 ; set . add ( cur ); if (! map . containsKey ( cur )) return - 1.0 ; for ( String neighbor : map . get ( cur ). keySet ()) { if ( set . contains ( neighbor )) continue ; double t = dfs ( neighbor , target , set ); if ( t - 1.0 ) return t * map . get ( cur ). get ( neighbor ); } return - 1.0 ; } Java(Union Find) class Node { String parent ; double ratio ; Node ( String parent , double ratio ) { this . parent = parent ; this . ratio = ratio ; } } class UnionFindSet { Map String , Node parents = new HashMap (); Node find ( String s ) { if (! parents . containsKey ( s )) return null ; Node n = parents . get ( s ); if (! n . parent . equals ( s )) { Node t = find ( n . parent ); n . parent = t . parent ; n . ratio *= t . ratio ; } return n ; } void union ( String s , String p , double ratio ) { boolean hasS = parents . containsKey ( s ); boolean hasP = parents . containsKey ( p ); if (! hasS ! hasP ) { parents . put ( s , new Node ( p , ratio )); parents . put ( p , new Node ( p , 1.0 )); } else if (! hasP ){ parents . put ( p , new Node ( s , 1.0 / ratio )); } else if (! hasS ) { parents . put ( s , new Node ( p , ratio )); } else { Node pS = find ( s ); Node pP = find ( p ); pS . parent = pP . parent ; pS . ratio = ratio / pS . ratio * pP . ratio ; } } } public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { UnionFindSet uf = new UnionFindSet (); for ( int i = 0 ; i equations . length ; i ++) { uf . union ( equations [ i ][ 0 ], equations [ i ][ 1 ], values [ i ]); } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { Node root_x = uf . find ( queries [ i ][ 0 ]), root_y = uf . find ( queries [ i ][ 1 ]); if ( root_x == null || root_y == null || ! root_x . parent . equals ( root_y . parent )) res [ i ] = - 1.0 ; else res [ i ] = root_x . ratio / root_y . ratio ; } return res ; } Java(Floyd Warshall Algorithm) public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { HashMap String , HashMap String , Double graph = new HashMap (); for ( int i = 0 ; i equations . length ; i ++) { graph . computeIfAbsent ( equations [ i ][ 0 ], f - new HashMap ()). put ( equations [ i ][ 1 ], values [ i ]); graph . computeIfAbsent ( equations [ i ][ 1 ], f - new HashMap ()). put ( equations [ i ][ 0 ], 1.0 / values [ i ]); } for ( String mid : graph . keySet ()) { for ( String src : graph . get ( mid ). keySet ()) { for ( String dest : graph . get ( mid ). keySet ()) { double val = graph . get ( src ). get ( mid ) * graph . get ( mid ). get ( dest ); graph . get ( src ). put ( dest , val ); } } } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { if (! graph . containsKey ( queries [ i ][ 0 ])) res [ i ] = - 1.0 ; else res [ i ] = graph . get ( queries [ i ][ 0 ]). getOrDefault ( queries [ i ][ 1 ], - 1.0 ); } return res ; } JavaScript var calcEquation = function ( equations , values , queries ) { var map = new Map (), valueMap = new Map (); for ( let i = 0 ; i equations . length ; i ++ ) { let x = equations [ i ][ 0 ]; let y = equations [ i ][ 1 ]; let v = values [ i ]; if ( ! map . has ( x )) { map . set ( x , []); valueMap . set ( x , []) } if ( ! map . has ( y )) { map . set ( y , []); valueMap . set ( y , []); } map . get ( x ). push ( y ); map . get ( y ). push ( x ); valueMap . get ( x ). push ( v ); valueMap . get ( y ). push ( 1.0 / v ); } var res = []; for ( let j = 0 ; j queries . length ; j ++ ) { let x = queries [ j ][ 0 ]; let y = queries [ j ][ 1 ]; if ( ! map . has ( x ) || ! map . has ( y )) { res . push ( - 1.0 ); continue ; } res . push ( dfs ( x , y , map , valueMap , new Set ())); } return res ; }; function dfs ( x , y , map , valueMap , set ) { if ( x === y ) return 1.0 ; set . add ( x ); let nextList = map . get ( x ); let valueList = valueMap . get ( x ); for ( let i = 0 ; i nextList . length ; i ++ ) { if ( set . has ( nextList [ i ])) continue ; let t = dfs ( nextList [ i ], y , map , valueMap , set ); if ( t - 1.0 ) return valueList [ i ] * t ; } return - 1.0 ; } C++(DFS) public : vector double calcEquation ( vector pair string , string equations , vector double values , vector pair string , string queries ) { unordered_map string , unordered_map string , double map ; for ( int i = 0 ; i equations . size (); i ++ ) { const string x = equations [ i ]. first ; const string y = equations [ i ]. second ; const double v = values [ i ]; map [ x ][ y ] = v ; map [ y ][ x ] = 1.0 / v ; } vector double res ; for ( const auto pair : queries ) { const string x = pair . first ; const string y = pair . second ; if ( ! map . count ( x ) || ! map . count ( y )) { res . push_back ( - 1.0 ); continue ; } else { unordered_set string set ; res . push_back ( dfs ( x , y , map , set )); } } return res ; } private : double dfs ( const string x , const string y , unordered_map string , unordered_map string , double map , unordered_set string set ) { if ( x == y ) return 1.0 ; set . insert ( x ); for ( const auto pair : map [ x ]) { const string next = pair . first ; if ( set . count ( next )) continue ; double t = dfs ( next , y , map , set ); if ( t - 1.0 ) return map [ x ][ next ] * t ; } return - 1.0 ; } C++(Union Find) public : vector double calcEquation ( vector pair string , string equations , vector double values , vector pair string , string queries ) { unordered_map string , pair string , double parents ; for ( int i = 0 ; i equations . size (); i ++ ) { const string x = equations [ i ]. first ; const string y = equations [ i ]. second ; const double v = values [ i ]; if ( ! parents . count ( x ) ! parents . count ( y )) { parents [ x ] = { y , v }; parents [ y ] = { y , 1.0 }; } else if ( ! parents . count ( y )) { parents [ y ] = { x , 1.0 / v }; } else if ( ! parents . count ( x )) { parents [ x ] = { y , v }; } else { const auto root_x = find ( x , parents ); const auto root_y = find ( y , parents ); parents [ root_x . first ] = { root_y . first , v / root_x . second * root_y . second }; } } vector double res ; for ( const auto pair : queries ) { const string x = pair . first ; const string y = pair . second ; if ( ! parents . count ( x ) || ! parents . count ( y )) { res . push_back ( - 1.0 ); continue ; } auto root_x = find ( x , parents ); auto root_y = find ( y , parents ); if ( root_x . first != root_y . first ) { res . push_back ( - 1.0 ); } else { res . push_back ( root_x . second / root_y . second ); } } return res ; } private : pair string , double find ( const string n , unordered_map string , pair string , double parents ) { if ( n != parents [ n ]. first ) { const auto p = find ( parents [ n ]. first , parents ); parents [ n ]. first = p . first ; parents [ n ]. second *= p . second ; } return parents [ n ]; }","title":"399 Evaluate Division"},{"location":"LeetCode/lc0339/#399-evaluate-division","text":"","title":"399. Evaluate Division"},{"location":"LeetCode/lc0339/#description","text":"Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.","title":"Description"},{"location":"LeetCode/lc0339/#example","text":"Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . return [6.0, 0.5, -1.0, 1.0, -1.0 ]. The input is: vector equations, vector values, vector queries ,where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector . According to the example above: equations = [ [ a , b ], [ b , c ] ], values = [2.0, 3.0], queries = [ [ a , c ], [ b , a ], [ a , e ], [ a , a ], [ x , x ] ].","title":"Example"},{"location":"LeetCode/lc0339/#javadfs","text":"Map String , Map String , Double map ; public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { map = new HashMap (); for ( int i = 0 ; i equations . length ; i ++) { String x = equations [ i ][ 0 ]; String y = equations [ i ][ 1 ]; double value = values [ i ]; map . putIfAbsent ( x , new HashMap String , Double ()); map . putIfAbsent ( y , new HashMap String , Double ()); map . get ( x ). put ( y , value ); map . get ( y ). put ( x , 1.0 / value ); } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { if (! map . containsKey ( queries [ i ][ 0 ]) || ! map . containsKey ( queries [ i ][ 0 ])) res [ i ] = - 1.0 ; else res [ i ] = dfs ( queries [ i ][ 0 ], queries [ i ][ 1 ], new HashSet String ()); } return res ; } double dfs ( String cur , String target , Set String set ) { if ( cur . equals ( target )) return 1.0 ; set . add ( cur ); if (! map . containsKey ( cur )) return - 1.0 ; for ( String neighbor : map . get ( cur ). keySet ()) { if ( set . contains ( neighbor )) continue ; double t = dfs ( neighbor , target , set ); if ( t - 1.0 ) return t * map . get ( cur ). get ( neighbor ); } return - 1.0 ; }","title":"Java(DFS)"},{"location":"LeetCode/lc0339/#javaunion-find","text":"class Node { String parent ; double ratio ; Node ( String parent , double ratio ) { this . parent = parent ; this . ratio = ratio ; } } class UnionFindSet { Map String , Node parents = new HashMap (); Node find ( String s ) { if (! parents . containsKey ( s )) return null ; Node n = parents . get ( s ); if (! n . parent . equals ( s )) { Node t = find ( n . parent ); n . parent = t . parent ; n . ratio *= t . ratio ; } return n ; } void union ( String s , String p , double ratio ) { boolean hasS = parents . containsKey ( s ); boolean hasP = parents . containsKey ( p ); if (! hasS ! hasP ) { parents . put ( s , new Node ( p , ratio )); parents . put ( p , new Node ( p , 1.0 )); } else if (! hasP ){ parents . put ( p , new Node ( s , 1.0 / ratio )); } else if (! hasS ) { parents . put ( s , new Node ( p , ratio )); } else { Node pS = find ( s ); Node pP = find ( p ); pS . parent = pP . parent ; pS . ratio = ratio / pS . ratio * pP . ratio ; } } } public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { UnionFindSet uf = new UnionFindSet (); for ( int i = 0 ; i equations . length ; i ++) { uf . union ( equations [ i ][ 0 ], equations [ i ][ 1 ], values [ i ]); } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { Node root_x = uf . find ( queries [ i ][ 0 ]), root_y = uf . find ( queries [ i ][ 1 ]); if ( root_x == null || root_y == null || ! root_x . parent . equals ( root_y . parent )) res [ i ] = - 1.0 ; else res [ i ] = root_x . ratio / root_y . ratio ; } return res ; }","title":"Java(Union Find)"},{"location":"LeetCode/lc0339/#javafloyd-warshall-algorithm","text":"public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { HashMap String , HashMap String , Double graph = new HashMap (); for ( int i = 0 ; i equations . length ; i ++) { graph . computeIfAbsent ( equations [ i ][ 0 ], f - new HashMap ()). put ( equations [ i ][ 1 ], values [ i ]); graph . computeIfAbsent ( equations [ i ][ 1 ], f - new HashMap ()). put ( equations [ i ][ 0 ], 1.0 / values [ i ]); } for ( String mid : graph . keySet ()) { for ( String src : graph . get ( mid ). keySet ()) { for ( String dest : graph . get ( mid ). keySet ()) { double val = graph . get ( src ). get ( mid ) * graph . get ( mid ). get ( dest ); graph . get ( src ). put ( dest , val ); } } } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { if (! graph . containsKey ( queries [ i ][ 0 ])) res [ i ] = - 1.0 ; else res [ i ] = graph . get ( queries [ i ][ 0 ]). getOrDefault ( queries [ i ][ 1 ], - 1.0 ); } return res ; }","title":"Java(Floyd Warshall Algorithm)"},{"location":"LeetCode/lc0339/#javascript","text":"var calcEquation = function ( equations , values , queries ) { var map = new Map (), valueMap = new Map (); for ( let i = 0 ; i equations . length ; i ++ ) { let x = equations [ i ][ 0 ]; let y = equations [ i ][ 1 ]; let v = values [ i ]; if ( ! map . has ( x )) { map . set ( x , []); valueMap . set ( x , []) } if ( ! map . has ( y )) { map . set ( y , []); valueMap . set ( y , []); } map . get ( x ). push ( y ); map . get ( y ). push ( x ); valueMap . get ( x ). push ( v ); valueMap . get ( y ). push ( 1.0 / v ); } var res = []; for ( let j = 0 ; j queries . length ; j ++ ) { let x = queries [ j ][ 0 ]; let y = queries [ j ][ 1 ]; if ( ! map . has ( x ) || ! map . has ( y )) { res . push ( - 1.0 ); continue ; } res . push ( dfs ( x , y , map , valueMap , new Set ())); } return res ; }; function dfs ( x , y , map , valueMap , set ) { if ( x === y ) return 1.0 ; set . add ( x ); let nextList = map . get ( x ); let valueList = valueMap . get ( x ); for ( let i = 0 ; i nextList . length ; i ++ ) { if ( set . has ( nextList [ i ])) continue ; let t = dfs ( nextList [ i ], y , map , valueMap , set ); if ( t - 1.0 ) return valueList [ i ] * t ; } return - 1.0 ; }","title":"JavaScript"},{"location":"LeetCode/lc0339/#cdfs","text":"public : vector double calcEquation ( vector pair string , string equations , vector double values , vector pair string , string queries ) { unordered_map string , unordered_map string , double map ; for ( int i = 0 ; i equations . size (); i ++ ) { const string x = equations [ i ]. first ; const string y = equations [ i ]. second ; const double v = values [ i ]; map [ x ][ y ] = v ; map [ y ][ x ] = 1.0 / v ; } vector double res ; for ( const auto pair : queries ) { const string x = pair . first ; const string y = pair . second ; if ( ! map . count ( x ) || ! map . count ( y )) { res . push_back ( - 1.0 ); continue ; } else { unordered_set string set ; res . push_back ( dfs ( x , y , map , set )); } } return res ; } private : double dfs ( const string x , const string y , unordered_map string , unordered_map string , double map , unordered_set string set ) { if ( x == y ) return 1.0 ; set . insert ( x ); for ( const auto pair : map [ x ]) { const string next = pair . first ; if ( set . count ( next )) continue ; double t = dfs ( next , y , map , set ); if ( t - 1.0 ) return map [ x ][ next ] * t ; } return - 1.0 ; }","title":"C++(DFS)"},{"location":"LeetCode/lc0339/#cunion-find","text":"public : vector double calcEquation ( vector pair string , string equations , vector double values , vector pair string , string queries ) { unordered_map string , pair string , double parents ; for ( int i = 0 ; i equations . size (); i ++ ) { const string x = equations [ i ]. first ; const string y = equations [ i ]. second ; const double v = values [ i ]; if ( ! parents . count ( x ) ! parents . count ( y )) { parents [ x ] = { y , v }; parents [ y ] = { y , 1.0 }; } else if ( ! parents . count ( y )) { parents [ y ] = { x , 1.0 / v }; } else if ( ! parents . count ( x )) { parents [ x ] = { y , v }; } else { const auto root_x = find ( x , parents ); const auto root_y = find ( y , parents ); parents [ root_x . first ] = { root_y . first , v / root_x . second * root_y . second }; } } vector double res ; for ( const auto pair : queries ) { const string x = pair . first ; const string y = pair . second ; if ( ! parents . count ( x ) || ! parents . count ( y )) { res . push_back ( - 1.0 ); continue ; } auto root_x = find ( x , parents ); auto root_y = find ( y , parents ); if ( root_x . first != root_y . first ) { res . push_back ( - 1.0 ); } else { res . push_back ( root_x . second / root_y . second ); } } return res ; } private : pair string , double find ( const string n , unordered_map string , pair string , double parents ) { if ( n != parents [ n ]. first ) { const auto p = find ( parents [ n ]. first , parents ); parents [ n ]. first = p . first ; parents [ n ]. second *= p . second ; } return parents [ n ]; }","title":"C++(Union Find)"}]}